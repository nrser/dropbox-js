// Generated by CoffeeScript 1.9.1
(function() {
  describe('Dropbox.Util.Xhr', function() {
    beforeEach(function() {
      return this.oauth = new Dropbox.Util.Oauth({
        key: 'mock00key',
        secret: 'mock00secret',
        token: 'mock00token'
      });
    });
    describe('with a GET', function() {
      beforeEach(function() {
        return this.xhr = new Dropbox.Util.Xhr('GET', 'https://request.url');
      });
      it('initializes correctly', function() {
        expect(this.xhr.isGet).to.equal(true);
        expect(this.xhr.method).to.equal('GET');
        expect(this.xhr.url).to.equal('https://request.url');
        return expect(this.xhr.preflight).to.equal(false);
      });
      describe('#setHeader', function() {
        beforeEach(function() {
          return this.xhr.setHeader('Range', 'bytes=0-1000');
        });
        it('adds a HTTP header header', function() {
          expect(this.xhr.headers).to.have.property('Range');
          return expect(this.xhr.headers['Range']).to.equal('bytes=0-1000');
        });
        it('does not work twice for the same header', function() {
          return expect((function(_this) {
            return function() {
              return _this.xhr.setHeader('Range', 'bytes=0-1000');
            };
          })(this)).to["throw"](Error);
        });
        it('flags the Xhr as needing preflight', function() {
          return expect(this.xhr.preflight).to.equal(true);
        });
        return it('rejects Content-Type', function() {
          return expect((function(_this) {
            return function() {
              return _this.xhr.setHeader('Content-Type', 'text/plain');
            };
          })(this)).to["throw"](Error);
        });
      });
      describe('#setParams', function() {
        beforeEach(function() {
          return this.xhr.setParams({
            'param 1': true,
            'answer': 42
          });
        });
        it('does not flag the XHR as needing preflight', function() {
          return expect(this.xhr.preflight).to.equal(false);
        });
        it('does not work twice', function() {
          return expect((function(_this) {
            return function() {
              return _this.xhr.setParams({
                'answer': 43
              });
            };
          })(this)).to["throw"](Error);
        });
        describe('#paramsToUrl', function() {
          beforeEach(function() {
            return this.xhr.paramsToUrl();
          });
          it('changes the url', function() {
            return expect(this.xhr.url).to.equal('https://request.url?answer=42&param%201=true');
          });
          return it('sets params to null', function() {
            return expect(this.xhr.params).to.equal(null);
          });
        });
        describe('#paramsToBody', function() {
          return it('throws an error', function() {
            return expect((function(_this) {
              return function() {
                return _this.xhr.paramsToBody();
              };
            })(this)).to["throw"](Error);
          });
        });
        describe('#addOauthParams', function() {
          beforeEach(function() {
            return this.xhr.addOauthParams(this.oauth);
          });
          it('keeps existing params', function() {
            expect(this.xhr.params).to.have.property('answer');
            return expect(this.xhr.params.answer).to.equal(42);
          });
          it('adds an access_token param', function() {
            return expect(this.xhr.params).to.have.property('access_token');
          });
          it('does not add an Authorization header', function() {
            return expect(this.xhr.headers).not.to.have.property('Authorization');
          });
          return it('does not work twice', function() {
            return expect((function(_this) {
              return function() {
                return _this.xhr.addOauthParams();
              };
            })(this)).to["throw"](Error);
          });
        });
        return describe('#addOauthHeader', function() {
          beforeEach(function() {
            return this.xhr.addOauthHeader(this.oauth);
          });
          it('keeps existing params', function() {
            expect(this.xhr.params).to.have.property('answer');
            return expect(this.xhr.params.answer).to.equal(42);
          });
          it('does not add an access_token param', function() {
            return expect(this.xhr.params).not.to.have.property('access_token');
          });
          return it('adds an Authorization header', function() {
            return expect(this.xhr.headers).to.have.property('Authorization');
          });
        });
      });
      describe('#addOauthParams without params', function() {
        beforeEach(function() {
          return this.xhr.addOauthParams(this.oauth);
        });
        return it('adds an access_token param', function() {
          return expect(this.xhr.params).to.have.property('access_token');
        });
      });
      describe('#addOauthHeader without params', function() {
        beforeEach(function() {
          return this.xhr.addOauthHeader(this.oauth);
        });
        return it('adds an Authorization header', function() {
          return expect(this.xhr.headers).to.have.property('Authorization');
        });
      });
      describe('#signWithOauth', function() {
        describe('for a request that does not need preflight', function() {
          beforeEach(function() {
            return this.xhr.signWithOauth(this.oauth);
          });
          if (Dropbox.Util.Xhr.doesPreflight) {
            return it('uses addOauthParams', function() {
              return expect(this.xhr.params).to.have.property('access_token');
            });
          } else {
            return it('uses addOauthHeader in node.js', function() {
              return expect(this.xhr.headers).to.have.property('Authorization');
            });
          }
        });
        describe('for a request that needs preflight', function() {
          beforeEach(function() {
            this.xhr.setHeader('Range', 'bytes=0-1000');
            return this.xhr.signWithOauth(this.oauth);
          });
          if (Dropbox.Util.Xhr.ieXdr) {
            return it('uses addOauthParams in IE', function() {
              return expect(this.xhr.params).to.have.property('access_token');
            });
          } else {
            return it('uses addOauthHeader', function() {
              return expect(this.xhr.headers).to.have.property('Authorization');
            });
          }
        });
        return describe('with cacheFriendly: true', function() {
          describe('for a request that does not need preflight', function() {
            beforeEach(function() {
              return this.xhr.signWithOauth(this.oauth, true);
            });
            if (Dropbox.Util.Xhr.ieXdr) {
              return it('uses addOauthParams in IE', function() {
                return expect(this.xhr.params).to.have.property('access_token');
              });
            } else {
              return it('uses addOauthHeader', function() {
                return expect(this.xhr.headers).to.have.property('Authorization');
              });
            }
          });
          return describe('for a request that needs preflight', function() {
            beforeEach(function() {
              this.xhr.setHeader('Range', 'bytes=0-1000');
              return this.xhr.signWithOauth(this.oauth, true);
            });
            if (Dropbox.Util.Xhr.ieXdr) {
              return it('uses addOauthParams in IE', function() {
                return expect(this.xhr.params).to.have.property('access_token');
              });
            } else {
              return it('uses addOauthHeader', function() {
                return expect(this.xhr.headers).to.have.property('Authorization');
              });
            }
          });
        });
      });
      describe('#setFileField', function() {
        return it('throws an error', function() {
          return expect((function(_this) {
            return function() {
              return _this.xhr.setFileField('file', 'filename.bin', '<p>File Data</p>', 'text/html');
            };
          })(this)).to["throw"](Error);
        });
      });
      describe('#setBody', function() {
        it('throws an error', function() {
          return expect((function(_this) {
            return function() {
              return _this.xhr.setBody('body data');
            };
          })(this)).to["throw"](Error);
        });
        return it('does not flag the XHR as needing preflight', function() {
          return expect(this.xhr.preflight).to.equal(false);
        });
      });
      describe('#setResponseType', function() {
        beforeEach(function() {
          return this.xhr.setResponseType('b');
        });
        it('changes responseType', function() {
          return expect(this.xhr.responseType).to.equal('b');
        });
        return it('does not flag the XHR as needing preflight', function() {
          return expect(this.xhr.preflight).to.equal(false);
        });
      });
      return describe('#prepare with params', function() {
        beforeEach(function() {
          this.xhr.setParams({
            answer: 42
          });
          return this.xhr.prepare();
        });
        it('creates the native xhr', function() {
          return expect(typeof this.xhr.xhr).to.equal('object');
        });
        it('opens the native xhr', function() {
          if (Dropbox.Util.Xhr.ieXdr) {
            return;
          }
          return expect(this.xhr.xhr.readyState).to.equal(1);
        });
        return it('pushes the params in the url', function() {
          return expect(this.xhr.url).to.equal('https://request.url?answer=42');
        });
      });
    });
    describe('with a POST', function() {
      beforeEach(function() {
        return this.xhr = new Dropbox.Util.Xhr('POST', 'https://request.url');
      });
      it('initializes correctly', function() {
        expect(this.xhr.isGet).to.equal(false);
        expect(this.xhr.method).to.equal('POST');
        expect(this.xhr.url).to.equal('https://request.url');
        return expect(this.xhr.preflight).to.equal(false);
      });
      describe('#setHeader', function() {
        beforeEach(function() {
          return this.xhr.setHeader('Range', 'bytes=0-1000');
        });
        it('adds a HTTP header header', function() {
          expect(this.xhr.headers).to.have.property('Range');
          return expect(this.xhr.headers['Range']).to.equal('bytes=0-1000');
        });
        it('does not work twice for the same header', function() {
          return expect((function(_this) {
            return function() {
              return _this.xhr.setHeader('Range', 'bytes=0-1000');
            };
          })(this)).to["throw"](Error);
        });
        it('flags the Xhr as needing preflight', function() {
          return expect(this.xhr.preflight).to.equal(true);
        });
        return it('rejects Content-Type', function() {
          return expect((function(_this) {
            return function() {
              return _this.xhr.setHeader('Content-Type', 'text/plain');
            };
          })(this)).to["throw"](Error);
        });
      });
      describe('#setParams', function() {
        beforeEach(function() {
          return this.xhr.setParams({
            'param 1': true,
            'answer': 42
          });
        });
        it('does not work twice', function() {
          return expect((function(_this) {
            return function() {
              return _this.xhr.setParams({
                'answer': 43
              });
            };
          })(this)).to["throw"](Error);
        });
        it('does not flag the XHR as needing preflight', function() {
          return expect(this.xhr.preflight).to.equal(false);
        });
        describe('#paramsToUrl', function() {
          beforeEach(function() {
            return this.xhr.paramsToUrl();
          });
          it('changes the url', function() {
            return expect(this.xhr.url).to.equal('https://request.url?answer=42&param%201=true');
          });
          it('sets params to null', function() {
            return expect(this.xhr.params).to.equal(null);
          });
          return it('does not set the body', function() {
            return expect(this.xhr.body).to.equal(null);
          });
        });
        describe('#paramsToBody', function() {
          beforeEach(function() {
            return this.xhr.paramsToBody();
          });
          it('url-encodes the params', function() {
            return expect(this.xhr.body).to.equal('answer=42&param%201=true');
          });
          it('sets the Content-Type header', function() {
            expect(this.xhr.headers).to.have.property('Content-Type');
            return expect(this.xhr.headers['Content-Type']).to.equal('application/x-www-form-urlencoded');
          });
          it('does not change the url', function() {
            return expect(this.xhr.url).to.equal('https://request.url');
          });
          return it('does not work twice', function() {
            this.xhr.setParams({
              answer: 43
            });
            return expect((function(_this) {
              return function() {
                return _this.xhr.paramsToBody();
              };
            })(this)).to["throw"](Error);
          });
        });
        describe('#addOauthParams', function() {
          beforeEach(function() {
            return this.xhr.addOauthParams(this.oauth);
          });
          it('keeps existing params', function() {
            expect(this.xhr.params).to.have.property('answer');
            return expect(this.xhr.params.answer).to.equal(42);
          });
          it('adds an access_token param', function() {
            return expect(this.xhr.params).to.have.property('access_token');
          });
          it('does not add an Authorization header', function() {
            return expect(this.xhr.headers).not.to.have.property('Authorization');
          });
          return it('does not work twice', function() {
            return expect((function(_this) {
              return function() {
                return _this.xhr.addOauthParams();
              };
            })(this)).to["throw"](Error);
          });
        });
        return describe('#addOauthHeader', function() {
          beforeEach(function() {
            return this.xhr.addOauthHeader(this.oauth);
          });
          it('keeps existing params', function() {
            expect(this.xhr.params).to.have.property('answer');
            return expect(this.xhr.params.answer).to.equal(42);
          });
          it('does not add an access_token param', function() {
            return expect(this.xhr.params).not.to.have.property('access_token');
          });
          return it('adds an Authorization header', function() {
            return expect(this.xhr.headers).to.have.property('Authorization');
          });
        });
      });
      describe('#addOauthParams without params', function() {
        beforeEach(function() {
          return this.xhr.addOauthParams(this.oauth);
        });
        return it('adds an access_token param', function() {
          return expect(this.xhr.params).to.have.property('access_token');
        });
      });
      describe('#addOauthHeader without params', function() {
        beforeEach(function() {
          return this.xhr.addOauthHeader(this.oauth);
        });
        return it('adds an Authorization header', function() {
          return expect(this.xhr.headers).to.have.property('Authorization');
        });
      });
      describe('#signWithOauth', function() {
        describe('for a request that does not need preflight', function() {
          beforeEach(function() {
            return this.xhr.signWithOauth(this.oauth);
          });
          if (Dropbox.Util.Xhr.doesPreflight) {
            return it('uses addOauthParams', function() {
              return expect(this.xhr.params).to.have.property('access_token');
            });
          } else {
            return it('uses addOauthHeader in node.js', function() {
              return expect(this.xhr.headers).to.have.property('Authorization');
            });
          }
        });
        describe('for a request that needs preflight', function() {
          beforeEach(function() {
            this.xhr.setHeader('Range', 'bytes=0-1000');
            return this.xhr.signWithOauth(this.oauth);
          });
          if (Dropbox.Util.Xhr.ieXdr) {
            return it('uses addOauthParams in IE', function() {
              return expect(this.xhr.params).to.have.property('access_token');
            });
          } else {
            return it('uses addOauthHeader', function() {
              return expect(this.xhr.headers).to.have.property('Authorization');
            });
          }
        });
        return describe('with cacheFriendly: true', function() {
          describe('for a request that does not need preflight', function() {
            beforeEach(function() {
              return this.xhr.signWithOauth(this.oauth, true);
            });
            if (Dropbox.Util.Xhr.doesPreflight) {
              return it('uses addOauthParams', function() {
                return expect(this.xhr.params).to.have.property('access_token');
              });
            } else {
              return it('uses addOauthHeader in node.js', function() {
                return expect(this.xhr.headers).to.have.property('Authorization');
              });
            }
          });
          return describe('for a request that needs preflight', function() {
            beforeEach(function() {
              this.xhr.setHeader('Range', 'bytes=0-1000');
              return this.xhr.signWithOauth(this.oauth, true);
            });
            if (Dropbox.Util.Xhr.ieXdr) {
              return it('uses addOauthParams in IE', function() {
                return expect(this.xhr.params).to.have.property('access_token');
              });
            } else {
              return it('uses addOauthHeader', function() {
                return expect(this.xhr.headers).to.have.property('Authorization');
              });
            }
          });
        });
      });
      describe('#setFileField with a String', function() {
        beforeEach(function() {
          this.nonceStub = sinon.stub(this.xhr, 'multipartBoundary');
          this.nonceStub.returns('multipart----boundary');
          return this.xhr.setFileField('file', 'filename.bin', '<p>File Data</p>', 'text/html');
        });
        afterEach(function() {
          return this.nonceStub.restore();
        });
        it('sets the Content-Type header', function() {
          expect(this.xhr.headers).to.have.property('Content-Type');
          return expect(this.xhr.headers['Content-Type']).to.equal('multipart/form-data; boundary=multipart----boundary');
        });
        it('sets the body', function() {
          return expect(this.xhr.body).to.equal("--multipart----boundary\r\nContent-Disposition: form-data; name=\"file\"; filename=\"filename.bin\"\r\nContent-Type: text/html\r\nContent-Transfer-Encoding: binary\r\n\r\n<p>File Data</p>\r\n--multipart----boundary--\r\n");
        });
        it('does not work twice', function() {
          return expect((function(_this) {
            return function() {
              return _this.xhr.setFileField('file', 'filename.bin', '<p>File Data</p>', 'text/html');
            };
          })(this)).to["throw"](Error);
        });
        return it('does not flag the XHR as needing preflight', function() {
          return expect(this.xhr.preflight).to.equal(false);
        });
      });
      describe('#setBody with a string', function() {
        beforeEach(function() {
          return this.xhr.setBody('body data');
        });
        it('sets the request body', function() {
          return expect(this.xhr.body).to.equal('body data');
        });
        it('does not work twice', function() {
          return expect((function(_this) {
            return function() {
              return _this.xhr.setBody('body data');
            };
          })(this)).to["throw"](Error);
        });
        return it('does not flag the XHR as needing preflight', function() {
          return expect(this.xhr.preflight).to.equal(false);
        });
      });
      describe('#setBody with FormData', function() {
        beforeEach(function() {
          var formData;
          if (typeof FormData !== "undefined" && FormData !== null) {
            formData = new FormData();
            formData.append('name', 'value');
            return this.xhr.setBody(formData);
          }
        });
        return it('does not flag the XHR as needing preflight', function() {
          if (typeof FormData === "undefined" || FormData === null) {
            return;
          }
          return expect(this.xhr.preflight).to.equal(false);
        });
      });
      describe('#setBody with Blob', function() {
        beforeEach(function() {
          var blob, blobError, builder;
          if (typeof Blob !== "undefined" && Blob !== null) {
            try {
              blob = new Blob(["abcdef"], {
                type: 'image/png'
              });
            } catch (_error) {
              blobError = _error;
              builder = new WebKitBlobBuilder;
              builder.append("abcdef");
              blob = builder.getBlob('image/png');
            }
            return this.xhr.setBody(blob);
          }
        });
        it('flags the XHR as needing preflight', function() {
          if (typeof Blob === "undefined" || Blob === null) {
            return;
          }
          return expect(this.xhr.preflight).to.equal(true);
        });
        return it('sets the Content-Type header', function() {
          if (typeof Blob === "undefined" || Blob === null) {
            return;
          }
          expect(this.xhr.headers).to.have.property('Content-Type');
          return expect(this.xhr.headers['Content-Type']).to.equal('application/octet-stream');
        });
      });
      describe('#setBody with ArrayBuffer', function() {
        beforeEach(function() {
          var buffer;
          if (typeof ArrayBuffer !== "undefined" && ArrayBuffer !== null) {
            buffer = new ArrayBuffer(5);
            return this.xhr.setBody(buffer);
          }
        });
        it('flags the XHR as needing preflight', function() {
          if (typeof ArrayBuffer === "undefined" || ArrayBuffer === null) {
            return;
          }
          return expect(this.xhr.preflight).to.equal(true);
        });
        return it('sets the Content-Type header', function() {
          if (typeof ArrayBuffer === "undefined" || ArrayBuffer === null) {
            return;
          }
          expect(this.xhr.headers).to.have.property('Content-Type');
          return expect(this.xhr.headers['Content-Type']).to.equal('application/octet-stream');
        });
      });
      describe('#setBody with ArrayBufferView', function() {
        beforeEach(function() {
          var view;
          if (typeof Uint8Array !== "undefined" && Uint8Array !== null) {
            view = new Uint8Array(5);
            return this.xhr.setBody(view);
          }
        });
        it('flags the XHR as needing preflight', function() {
          if (typeof Uint8Array === "undefined" || Uint8Array === null) {
            return;
          }
          return expect(this.xhr.preflight).to.equal(true);
        });
        return it('sets the Content-Type header', function() {
          if (typeof Uint8Array === "undefined" || Uint8Array === null) {
            return;
          }
          expect(this.xhr.headers).to.have.property('Content-Type');
          return expect(this.xhr.headers['Content-Type']).to.equal('application/octet-stream');
        });
      });
      describe('#setBody with node.js Buffer', function() {
        beforeEach(function() {
          if (typeof Buffer !== "undefined" && Buffer !== null) {
            return this.xhr.setBody(new Buffer(5));
          }
        });
        it('flags the XHR as needing preflight', function() {
          if (typeof Buffer === "undefined" || Buffer === null) {
            return;
          }
          return expect(this.xhr.preflight).to.equal(true);
        });
        return it('sets the Content-Type header', function() {
          if (typeof Buffer === "undefined" || Buffer === null) {
            return;
          }
          expect(this.xhr.headers).to.have.property('Content-Type');
          return expect(this.xhr.headers['Content-Type']).to.equal('application/octet-stream');
        });
      });
      describe('#setResponseType', function() {
        beforeEach(function() {
          return this.xhr.setResponseType('b');
        });
        it('changes responseType', function() {
          return expect(this.xhr.responseType).to.equal('b');
        });
        return it('does not flag the XHR as needing preflight', function() {
          return expect(this.xhr.preflight).to.equal(false);
        });
      });
      return describe('#prepare with params', function() {
        beforeEach(function() {
          this.xhr.setParams({
            answer: 42
          });
          return this.xhr.prepare();
        });
        it('creates the native xhr', function() {
          return expect(typeof this.xhr.xhr).to.equal('object');
        });
        it('opens the native xhr', function() {
          if (Dropbox.Util.Xhr.ieXdr) {
            return;
          }
          return expect(this.xhr.xhr.readyState).to.equal(1);
        });
        if (Dropbox.Util.Xhr.ieXdr) {
          return it('keeps the params in the URL in IE', function() {
            expect(this.xhr.url).to.equal('https://request.url?answer=42');
            return expect(this.xhr.body).to.equal(null);
          });
        } else {
          return it('pushes the params in the body', function() {
            return expect(this.xhr.body).to.equal('answer=42');
          });
        }
      });
    });
    describe('with a PUT', function() {
      beforeEach(function() {
        return this.xhr = new Dropbox.Util.Xhr('PUT', 'https://request.url');
      });
      return it('initializes correctly', function() {
        expect(this.xhr.isGet).to.equal(false);
        expect(this.xhr.method).to.equal('PUT');
        expect(this.xhr.url).to.equal('https://request.url');
        return expect(this.xhr.preflight).to.equal(true);
      });
    });
    describe('#urlEncode', function() {
      it('iterates properly', function() {
        return expect(Dropbox.Util.Xhr.urlEncode({
          foo: 'bar',
          baz: 5
        })).to.equal('baz=5&foo=bar');
      });
      it('percent-encodes properly', function() {
        return expect(Dropbox.Util.Xhr.urlEncode({
          'a +x()': "*b'"
        })).to.equal('a%20%2Bx%28%29=%2Ab%27');
      });
      return it('does-not percent-encode characters singled out by OAuth spec', function() {
        return expect(Dropbox.Util.Xhr.urlEncode({
          'key': '1-2.3_4~'
        })).to.equal('key=1-2.3_4~');
      });
    });
    describe('#urlDecode', function() {
      it('iterates properly', function() {
        var decoded;
        decoded = Dropbox.Util.Xhr.urlDecode('baz=5&foo=bar');
        expect(decoded['baz']).to.equal('5');
        return expect(decoded['foo']).to.equal('bar');
      });
      return it('percent-decodes properly', function() {
        var decoded;
        decoded = Dropbox.Util.Xhr.urlDecode('a%20%2Bx%28%29=%2Ab%27');
        return expect(decoded['a +x()']).to.equal("*b'");
      });
    });
    describe('#parseResponseHeaders', function() {
      it('parses one header correctly', function() {
        var decoded, headers;
        headers = "Content-Type: 35225";
        decoded = Dropbox.Util.Xhr.parseResponseHeaders(headers);
        return expect(decoded).to.deep.equal({
          'content-type': '35225'
        });
      });
      return it('parses multiple headers correctly', function() {
        var decoded, headers;
        headers = "Content-Type: 35225\n s : t\ndiffic ULT: Random: value: with: colons";
        decoded = Dropbox.Util.Xhr.parseResponseHeaders(headers);
        return expect(decoded).to.deep.equal({
          'content-type': '35225',
          's': 't',
          'diffic ult': 'Random: value: with: colons'
        });
      });
    });
    return describe('#send', function() {
      beforeEach(function() {
        var agent, https, ref;
        this.node_js = (typeof module !== "undefined" && module !== null) && ((typeof module !== "undefined" && module !== null ? module.exports : void 0) != null) && (typeof require !== "undefined" && require !== null);
        if (this.node_js) {
          this.XMLHttpRequest = require('xhr2');
          this.oldAgent = this.XMLHttpRequest.nodejsHttpsAgent;
          https = require('https');
          agent = new https.Agent;
          agent.options.rejectUnauthorized = false;
          this.XMLHttpRequest.nodejsSet({
            httpsAgent: agent
          });
        }
        this.cordova = typeof cordova !== "undefined" && cordova !== null;
        return this.chrome_app = (typeof chrome !== "undefined" && chrome !== null) && (chrome.extension || ((ref = chrome.app) != null ? ref.runtime : void 0));
      });
      afterEach(function() {
        if (this.node_js) {
          return this.XMLHttpRequest.nodejsSet({
            httpsAgent: this.oldAgent
          });
        }
      });
      it('processes form-urlencoded data correctly', function(done) {
        var url, xhr;
        if (this.cordova) {
          return done();
        }
        url = testXhrServer + '/form_encoded';
        xhr = new Dropbox.Util.Xhr('POST', url);
        return xhr.prepare().send(function(error, data) {
          expect(error).to.not.be.ok;
          expect(data).to.have.property('access_token');
          expect(data.access_token).to.equal('test token');
          expect(data).to.have.property('token_type');
          expect(data.token_type).to.equal('Bearer');
          return done();
        });
      });
      it('processes form-urlencoded+charset data correctly', function(done) {
        var url, xhr;
        if (this.cordova) {
          return done();
        }
        url = testXhrServer + '/form_encoded?charset=utf8';
        xhr = new Dropbox.Util.Xhr('POST', url);
        return xhr.prepare().send(function(error, data) {
          expect(error).to.not.be.ok;
          expect(data).to.have.property('access_token');
          expect(data.access_token).to.equal('test token');
          return done();
        });
      });
      it('processes JSON-encoded data correctly', function(done) {
        var url, xhr;
        if (this.cordova) {
          return done();
        }
        url = testXhrServer + '/json_encoded';
        xhr = new Dropbox.Util.Xhr('POST', url);
        return xhr.prepare().send(function(error, data) {
          expect(error).to.not.be.ok;
          expect(data).to.have.property('uid');
          expect(data.uid).to.equal(42);
          expect(data).to.have.property('country');
          expect(data.country).to.equal('US');
          expect(data).to.have.property('display_name');
          expect(data.display_name).to.equal('John P. User');
          return done();
        });
      });
      it('processes JSON-encoded+charset data correctly', function(done) {
        var url, xhr;
        if (this.cordova) {
          return done();
        }
        url = testXhrServer + '/json_encoded?charset=utf8';
        xhr = new Dropbox.Util.Xhr('POST', url);
        return xhr.prepare().send(function(error, data) {
          expect(error).to.not.be.ok;
          expect(data).to.have.property('uid');
          expect(data.uid).to.equal(42);
          return done();
        });
      });
      it('processes data correctly when using setCallback', function(done) {
        var url, xhr;
        if (this.cordova) {
          return done();
        }
        url = testXhrServer + '/form_encoded';
        xhr = new Dropbox.Util.Xhr('POST', url);
        xhr.setCallback(function(error, data) {
          expect(error).to.not.be.ok;
          expect(data).to.have.property('access_token');
          expect(data.access_token).to.equal('test token');
          expect(data).to.have.property('token_type');
          expect(data.token_type).to.equal('Bearer');
          return done();
        });
        return xhr.prepare().send();
      });
      it('processes data and headers correctly', function(done) {
        var url, xhr;
        if (this.cordova) {
          return done();
        }
        url = testXhrServer + '/form_encoded';
        xhr = new Dropbox.Util.Xhr('POST', url);
        xhr.reportResponseHeaders();
        return xhr.prepare().send(function(error, data, metadata, headers) {
          expect(error).to.not.be.ok;
          expect(data).to.have.property('access_token');
          expect(data.access_token).to.equal('test token');
          expect(data).to.have.property('token_type');
          expect(data.token_type).to.equal('Bearer');
          expect(headers).to.have.property('content-type');
          expect(headers['content-type']).to.equal('application/x-www-form-urlencoded');
          return done();
        });
      });
      describe('with a binary response', function() {
        beforeEach(function() {
          return this.xhr = new Dropbox.Util.Xhr('GET', testXhrServer + '/test/binary/dropbox.png');
        });
        describe('with responseType b', function() {
          beforeEach(function() {
            return this.xhr.setResponseType('b');
          });
          return it('retrieves a string where each character is a byte', function(done) {
            if (this.cordova) {
              return done();
            }
            return this.xhr.prepare().send(function(error, data) {
              var bytes, i;
              expect(error).to.not.be.ok;
              expect(data).to.be.a('string');
              bytes = (function() {
                var j, ref, results;
                results = [];
                for (i = j = 0, ref = data.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                  results.push(data.charCodeAt(i));
                }
                return results;
              })();
              expect(bytes).to.deep.equal(testImageBytes);
              return done();
            });
          });
        });
        describe('with responseType arraybuffer', function() {
          beforeEach(function() {
            return this.xhr.setResponseType('arraybuffer');
          });
          return it('retrieves a well-formed ArrayBuffer', function(done) {
            if (this.cordova) {
              return done();
            }
            if (typeof ArrayBuffer === "undefined" || ArrayBuffer === null) {
              return done();
            }
            return this.xhr.prepare().send(function(error, buffer) {
              var bytes, i, view;
              expect(error).to.not.be.ok;
              expect(buffer).to.be.instanceOf(ArrayBuffer);
              view = new Uint8Array(buffer);
              bytes = (function() {
                var j, ref, results;
                results = [];
                for (i = j = 0, ref = buffer.byteLength; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                  results.push(view[i]);
                }
                return results;
              })();
              expect(bytes).to.deep.equal(testImageBytes);
              return done();
            });
          });
        });
        describe('with responseType blob', function() {
          beforeEach(function() {
            return this.xhr.setResponseType('blob');
          });
          return it('retrieves a well-formed Blob', function(done) {
            if (this.cordova) {
              return done();
            }
            if (typeof Blob === "undefined" || Blob === null) {
              return done();
            }
            return this.xhr.prepare().send(function(error, blob) {
              var buffer, onBufferAvailable, reader;
              expect(error).to.not.be.ok;
              expect(blob).to.be.instanceOf(Blob);
              onBufferAvailable = function(buffer) {
                var bytes, i, view;
                view = new Uint8Array(buffer);
                bytes = (function() {
                  var j, ref, results;
                  results = [];
                  for (i = j = 0, ref = buffer.byteLength; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                    results.push(view[i]);
                  }
                  return results;
                })();
                expect(bytes).to.deep.equal(testImageBytes);
                return done();
              };
              if (typeof FileReaderSync !== 'undefined') {
                reader = new FileReaderSync;
                buffer = reader.readAsArrayBuffer(blob);
                return onBufferAvailable(buffer);
              } else {
                reader = new FileReader;
                reader.onloadend = function() {
                  if (reader.readyState !== FileReader.DONE) {
                    return;
                  }
                  return onBufferAvailable(reader.result);
                };
                return reader.readAsArrayBuffer(blob);
              }
            });
          });
        });
        return describe('with responseType buffer', function() {
          beforeEach(function() {
            if (typeof Buffer !== "undefined" && Buffer !== null) {
              return this.xhr.setResponseType('buffer');
            }
          });
          return it('retrieves a well-formed Buffer on node.js', function(done) {
            if (typeof Buffer === "undefined" || Buffer === null) {
              return done();
            }
            return this.xhr.prepare().send(function(error, buffer) {
              var bytes, i;
              expect(error).to.not.be.ok;
              expect(buffer).to.be.instanceOf(Buffer);
              bytes = (function() {
                var j, ref, results;
                results = [];
                for (i = j = 0, ref = buffer.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                  results.push(buffer.readUInt8(i));
                }
                return results;
              })();
              expect(bytes).to.deep.equal(testImageBytes);
              return done();
            });
          });
        });
      });
      it('sends Authorization headers correctly', function(done) {
        var xhr;
        if (Dropbox.Util.Xhr.ieXdr) {
          return done();
        }
        if (this.cordova) {
          return done();
        }
        xhr = new Dropbox.Util.Xhr('GET', testXhrServer + '/dropbox_file');
        xhr.addOauthHeader(this.oauth);
        return xhr.prepare().send((function(_this) {
          return function(error, data) {
            expect(error).to.equal(null);
            expect(data).to.equal('Test file contents');
            xhr = new Dropbox.Util.Xhr('GET', testXhrServer + '/dropbox_file');
            _this.oauth.setCredentials({
              token: 'wrong00token'
            });
            xhr.addOauthHeader(_this.oauth);
            return xhr.prepare().send(function(error, data) {
              expect(data).not.to.be.ok;
              expect(error).to.be.instanceOf(Dropbox.ApiError);
              return done();
            });
          };
        })(this));
      });
      it('parses X-Dropbox-Metadata correctly', function(done) {
        var xhr;
        if (Dropbox.Util.Xhr.ieXdr) {
          return done();
        }
        if (this.cordova) {
          return done();
        }
        xhr = new Dropbox.Util.Xhr('GET', testXhrServer + '/dropbox_file');
        xhr.addOauthHeader(this.oauth);
        return xhr.prepare().send((function(_this) {
          return function(error, data, metadata) {
            expect(error).to.equal(null);
            expect(data).to.equal('Test file contents');
            expect(metadata).to.have.property('size');
            expect(metadata.size).to.equal('1KB');
            expect(metadata).to.have.property('is_dir');
            expect(metadata.is_dir).to.equal(false);
            expect(metadata).to.have.property('path');
            expect(metadata.path).to.equal('/test_path.txt');
            return done();
          };
        })(this));
      });
      it("doesn't crash on unparseable X-Dropbox-Metadata", function(done) {
        var xhr;
        if (this.cordova) {
          return done();
        }
        xhr = new Dropbox.Util.Xhr('GET', testXhrServer + '/dropbox_file_bug/txt');
        return xhr.prepare().send((function(_this) {
          return function(error, data, metadata) {
            expect(error).to.equal(null);
            expect(data).to.equal('Test file contents');
            expect(metadata).not.to.be.ok;
            return done();
          };
        })(this));
      });
      it('parses doubled X-Dropbox-Metadata header', function(done) {
        var xhr;
        if (Dropbox.Util.Xhr.ieXdr) {
          return done();
        }
        if (this.cordova) {
          return done();
        }
        xhr = new Dropbox.Util.Xhr('GET', testXhrServer + '/dropbox_file_bug/2x');
        return xhr.prepare().send((function(_this) {
          return function(error, data, metadata) {
            expect(error).to.equal(null);
            expect(data).to.equal('Test file contents');
            expect(metadata).to.have.property('size');
            expect(metadata.size).to.equal('1KB');
            expect(metadata).to.have.property('is_dir');
            expect(metadata.is_dir).to.equal(false);
            expect(metadata).to.have.property('path');
            expect(metadata.path).to.equal('/test_path.txt');
            return done();
          };
        })(this));
      });
      it('reports errors correctly', function(done) {
        var url, xhr;
        if (this.cordova) {
          return done();
        }
        url = testXhrServer + '/dropbox_file';
        xhr = new Dropbox.Util.Xhr('GET', url);
        return xhr.prepare().send((function(_this) {
          return function(error, data) {
            expect(data).to.equal(void 0);
            expect(error).to.be.instanceOf(Dropbox.ApiError);
            expect(error).to.have.property('url');
            expect(error.url).to.equal(url);
            expect(error).to.have.property('method');
            expect(error.method).to.equal('GET');
            if (!Dropbox.Util.Xhr.ieXdr) {
              expect(error).to.have.property('status');
              expect(error.status).to.equal(Dropbox.ApiError.INVALID_TOKEN);
            }
            if (!Dropbox.Util.Xhr.ieXdr) {
              expect(error).to.have.property('responseText');
              expect(error.responseText).to.be.a('string');
              expect(error.responseText).to.equal('{"error":"invalid access token"}');
              expect(error).to.have.property('response');
              expect(error.response).to.have.property('error');
              expect(error.response.error).to.equal('invalid access token');
            }
            expect(error.toString()).to.match(/^Dropbox API error/);
            expect(error.toString()).to.contain('GET');
            expect(error.toString()).to.contain(url);
            if (!Dropbox.Util.Xhr.ieXdr) {
              expect(error.toString()).to.contain('invalid access token');
            }
            return done();
          };
        })(this));
      });
      it('reports errors correctly when onError is set', function(done) {
        var listenerError, url, xhr, xhrCallbackCalled;
        if (this.cordova) {
          return done();
        }
        url = testXhrServer + '/dropbox_file';
        xhr = new Dropbox.Util.Xhr('GET', url);
        listenerError = null;
        xhrCallbackCalled = false;
        xhr.onError = function(error, callback) {
          expect(listenerError).to.equal(null);
          expect(xhrCallbackCalled).to.equal(false);
          listenerError = error;
          return callback(error);
        };
        return xhr.prepare().send((function(_this) {
          return function(error, data) {
            xhrCallbackCalled = true;
            expect(data).to.equal(void 0);
            expect(error).to.be.instanceOf(Dropbox.ApiError);
            expect(error).to.have.property('url');
            expect(error.url).to.equal(url);
            expect(error).to.have.property('method');
            expect(error.method).to.equal('GET');
            expect(listenerError).to.equal(error);
            return done();
          };
        })(this));
      });
      return it('reports network errors correctly', function(done) {
        var url, xhr;
        url = 'https://broken.to.causeanetworkerror.com/1/oauth/request_token';
        xhr = new Dropbox.Util.Xhr('POST', url);
        return xhr.prepare().send((function(_this) {
          return function(error, data) {
            expect(data).to.equal(void 0);
            expect(error).to.be.instanceOf(Dropbox.ApiError);
            expect(error).to.have.property('url');
            expect(error.url).to.equal(url);
            expect(error).to.have.property('method');
            expect(error.method).to.equal('POST');
            expect(error).to.have.property('responseText');
            expect(error.responseText).to.equal('(no response)');
            if (!Dropbox.Util.Xhr.ieXdr) {
              expect(error).to.have.property('status');
              expect(error.status).to.equal(Dropbox.ApiError.NETWORK_ERROR);
            }
            return done();
          };
        })(this));
      });
    });
  });

}).call(this);
