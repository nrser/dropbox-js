// Generated by CoffeeScript 1.9.1
(function() {
  var buildBlob, buildClientTests;

  buildBlob = function(fragments, mimeType) {
    var blobError, builder, fragment, j, len;
    try {
      return new Blob(fragments, mimeType);
    } catch (_error) {
      blobError = _error;
      builder = new WebKitBlobBuilder;
      for (j = 0, len = fragments.length; j < len; j++) {
        fragment = fragments[j];
        builder.append(fragment);
      }
      return builder.getBlob(mimeType);
    }
  };

  buildClientTests = function(clientKeys) {
    var setupClient, setupDirectory, setupImageFile, setupImageFileUsingArrayBuffer, setupImageFileUsingBlob, setupImageFileUsingString, setupTextFile;
    setupClient = function(test, done) {
      test.__client = new Dropbox.Client(clientKeys);
      return done();
    };
    setupDirectory = function(test, done) {
      test.node_js = (typeof module !== "undefined" && module !== null) && ((typeof module !== "undefined" && module !== null ? module.exports : void 0) != null) && (typeof require !== "undefined" && require !== null);
      test.testFolder = '/js tests.' + Math.random().toString(36);
      return test.__client.mkdir(test.testFolder, function(error, stat) {
        if (error !== null) {
          console.error(error);
          throw new Error("Unexpected setup error");
        }
        return done();
      });
    };
    setupImageFile = function(test, done) {
      test.imageFile = test.testFolder + "/test-binary-image.png";
      test.imageFileBytes = testImageBytes;
      return setupImageFileUsingArrayBuffer(test, function(success) {
        if (success) {
          return done();
        }
        return setupImageFileUsingBlob(test, function(success) {
          if (success) {
            return done();
          }
          return setupImageFileUsingString(test, done);
        });
      });
    };
    setupImageFileUsingArrayBuffer = function(test, done) {
      var buffer, i, j, ref, view;
      if (typeof Uint8Array !== "undefined" && Uint8Array !== null) {
        view = new Uint8Array(test.imageFileBytes.length);
        for (i = j = 0, ref = test.imageFileBytes.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          view[i] = test.imageFileBytes[i];
        }
        buffer = view.buffer;
        return test.__client.writeFile(test.imageFile, buffer, function(error, stat) {
          if (error) {
            return done(false);
          }
          if (stat.size === buffer.byteLength) {
            test.imageFileTag = stat.versionTag;
            return done(true);
          } else {
            return done(false);
          }
        });
      } else {
        return done(false);
      }
    };
    setupImageFileUsingBlob = function(test, done) {
      var blob, buffer, i, j, ref, view;
      if (typeof Blob !== "undefined" && Blob !== null) {
        view = new Uint8Array(test.imageFileBytes.length);
        for (i = j = 0, ref = test.imageFileBytes.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          view[i] = test.imageFileBytes[i];
        }
        buffer = view.buffer;
        blob = buildBlob([buffer], {
          type: 'image/png'
        });
        return test.__client.writeFile(test.imageFile, blob, function(error, stat) {
          if (error) {
            return done(false);
          }
          if (stat.size === blob.size) {
            test.imageFileTag = stat.versionTag;
            return done(true);
          } else {
            return done(false);
          }
        });
      } else {
        return done(false);
      }
    };
    setupImageFileUsingString = function(test, done) {
      var i, stringChars;
      stringChars = (function() {
        var j, ref, results;
        results = [];
        for (i = j = 0, ref = test.imageFileBytes.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          results.push(String.fromCharCode(test.imageFileBytes[i]));
        }
        return results;
      })();
      return test.__client.writeFile(test.imageFile, stringChars.join(''), {
        binary: true
      }, function(error, stat) {
        if (error !== null) {
          console.error(error);
          throw new Error("Unexpected setup error");
        }
        test.imageFileTag = stat.versionTag;
        return done();
      });
    };
    setupTextFile = function(test, done) {
      test.textFile = test.testFolder + "/test-file.txt";
      test.textFileData = "Plaintext test file " + (Math.random().toString(36)) + ".\n";
      return test.__client.writeFile(test.textFile, test.textFileData, function(error, stat) {
        if (error !== null) {
          console.error(error);
          throw new Error("Unexpected setup error");
        }
        test.textFileTag = stat.versionTag;
        return done();
      });
    };
    before(function(done) {
      return setupClient(this, (function(_this) {
        return function() {
          return setupDirectory(_this, function() {
            return setupImageFile(_this, function() {
              return setupTextFile(_this, function() {
                return done();
              });
            });
          });
        };
      })(this));
    });
    after(function(done) {
      return this.__client.remove(this.testFolder, (function(_this) {
        return function(error, stat) {
          if (error) {
            throw new Error(error);
          }
          return done();
        };
      })(this));
    });
    beforeEach(function() {
      return this.client = new Dropbox.Client(clientKeys);
    });
    describe('#getAccountInfo', function() {
      it('returns reasonable information', function(done) {
        return this.client.getAccountInfo(function(error, accountInfo, rawAccountInfo) {
          expect(error).to.equal(null);
          expect(accountInfo).to.be.instanceOf(Dropbox.AccountInfo);
          expect(accountInfo.uid).to.equal(clientKeys.uid);
          expect(rawAccountInfo).not.to.be.instanceOf(Dropbox.AccountInfo);
          expect(rawAccountInfo).to.have.property('uid');
          return done();
        });
      });
      return describe('with httpCache', function() {
        beforeEach(function() {
          this.xhr = null;
          return this.client.onXhr.addListener((function(_this) {
            return function(xhr) {
              return _this.xhr = xhr;
            };
          })(this));
        });
        return it('uses Authorization headers', function(done) {
          return this.client.getAccountInfo({
            httpCache: true
          }, (function(_this) {
            return function(error, accountInfo, rawAccountInfo) {
              if (Dropbox.Util.Xhr.ieXdr) {
                expect(_this.xhr.url).to.contain('access_token');
              } else {
                expect(_this.xhr.headers).to.have.key('Authorization');
              }
              expect(error).to.equal(null);
              expect(accountInfo).to.be.instanceOf(Dropbox.AccountInfo);
              expect(accountInfo.uid).to.equal(clientKeys.uid);
              expect(rawAccountInfo).not.to.be.instanceOf(Dropbox.AccountInfo);
              expect(rawAccountInfo).to.have.property('uid');
              return done();
            };
          })(this));
        });
      });
    });
    describe('#mkdir', function() {
      afterEach(function(done) {
        if (!this.newFolder) {
          return done();
        }
        return this.client.remove(this.newFolder, function(error, stat) {
          return done();
        });
      });
      return it('creates a folder in the test folder', function(done) {
        this.newFolder = this.testFolder + "/test'folder";
        return this.client.mkdir(this.newFolder, (function(_this) {
          return function(error, stat) {
            expect(error).to.equal(null);
            expect(stat).to.be.instanceOf(Dropbox.File.Stat);
            expect(stat.path).to.equal(_this.newFolder);
            expect(stat.isFolder).to.equal(true);
            return _this.client.stat(_this.newFolder, function(error, stat) {
              expect(error).to.equal(null);
              expect(stat.isFolder).to.equal(true);
              return done();
            });
          };
        })(this));
      });
    });
    describe('#readFile', function() {
      beforeEach(function() {
        return this.newFile = null;
      });
      afterEach(function(done) {
        if (!this.newFile) {
          return done();
        }
        return this.client.remove(this.newFile, function(error, stat) {
          return done();
        });
      });
      it('reads a text file', function(done) {
        return this.client.readFile(this.textFile, (function(_this) {
          return function(error, data, stat) {
            expect(error).to.equal(null);
            expect(data).to.equal(_this.textFileData);
            if (!Dropbox.Util.Xhr.ieXdr) {
              expect(stat).to.be.instanceOf(Dropbox.File.Stat);
              expect(stat.path).to.equal(_this.textFile);
              expect(stat.isFile).to.equal(true);
            }
            return done();
          };
        })(this));
      });
      it('reads the beginning of a text file', function(done) {
        if (Dropbox.Util.Xhr.ieXdr) {
          return done();
        }
        return this.client.readFile(this.textFile, {
          start: 0,
          length: 10
        }, (function(_this) {
          return function(error, data, stat, rangeInfo) {
            expect(error).to.equal(null);
            expect(data).to.equal(_this.textFileData.substring(0, 10));
            expect(stat).to.be.instanceOf(Dropbox.File.Stat);
            expect(stat.path).to.equal(_this.textFile);
            expect(stat.isFile).to.equal(true);
            expect(rangeInfo).to.be.instanceOf(Dropbox.Http.RangeInfo);
            expect(rangeInfo.start).to.equal(0);
            expect(rangeInfo.end).to.equal(9);
            expect(rangeInfo.size).to.equal(_this.textFileData.length);
            return done();
          };
        })(this));
      });
      it('reads the middle of a text file', function(done) {
        if (Dropbox.Util.Xhr.ieXdr) {
          return done();
        }
        return this.client.readFile(this.textFile, {
          start: 8,
          length: 10
        }, (function(_this) {
          return function(error, data, stat, rangeInfo) {
            expect(error).to.equal(null);
            expect(data).to.equal(_this.textFileData.substring(8, 18));
            expect(stat).to.be.instanceOf(Dropbox.File.Stat);
            expect(stat.path).to.equal(_this.textFile);
            expect(stat.isFile).to.equal(true);
            expect(rangeInfo).to.be.instanceOf(Dropbox.Http.RangeInfo);
            expect(rangeInfo.start).to.equal(8);
            expect(rangeInfo.end).to.equal(17);
            expect(rangeInfo.size).to.equal(_this.textFileData.length);
            return done();
          };
        })(this));
      });
      it('reads the end of a text file via the start: option', function(done) {
        if (Dropbox.Util.Xhr.ieXdr) {
          return done();
        }
        return this.client.readFile(this.textFile, {
          start: 10
        }, (function(_this) {
          return function(error, data, stat, rangeInfo) {
            expect(error).to.equal(null);
            expect(data).to.equal(_this.textFileData.substring(10));
            expect(stat).to.be.instanceOf(Dropbox.File.Stat);
            expect(stat.path).to.equal(_this.textFile);
            expect(stat.isFile).to.equal(true);
            expect(rangeInfo).to.be.instanceOf(Dropbox.Http.RangeInfo);
            expect(rangeInfo.start).to.equal(10);
            expect(rangeInfo.end).to.equal(_this.textFileData.length - 1);
            expect(rangeInfo.size).to.equal(_this.textFileData.length);
            return done();
          };
        })(this));
      });
      it('reads the end of a text file via the length: option', function(done) {
        if (Dropbox.Util.Xhr.ieXdr) {
          return done();
        }
        return this.client.readFile(this.textFile, {
          length: 10
        }, (function(_this) {
          return function(error, data, stat, rangeInfo) {
            expect(error).to.equal(null);
            expect(data).to.equal(_this.textFileData.substring(_this.textFileData.length - 10));
            expect(stat).to.be.instanceOf(Dropbox.File.Stat);
            expect(stat.path).to.equal(_this.textFile);
            expect(stat.isFile).to.equal(true);
            expect(rangeInfo).to.be.instanceOf(Dropbox.Http.RangeInfo);
            expect(rangeInfo.start).to.equal(_this.textFileData.length - 10);
            expect(rangeInfo.end).to.equal(_this.textFileData.length - 1);
            expect(rangeInfo.size).to.equal(_this.textFileData.length);
            return done();
          };
        })(this));
      });
      it('reads a binary file into a string', function(done) {
        return this.client.readFile(this.imageFile, {
          binary: true
        }, (function(_this) {
          return function(error, data, stat) {
            var bytes, i;
            expect(error).to.equal(null);
            bytes = (function() {
              var j, ref, results;
              results = [];
              for (i = j = 0, ref = data.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                results.push(data.charCodeAt(i));
              }
              return results;
            })();
            expect(bytes).to.deep.equal(_this.imageFileBytes);
            if (!Dropbox.Util.Xhr.ieXdr) {
              expect(stat).to.be.instanceOf(Dropbox.File.Stat);
              expect(stat.path).to.equal(_this.imageFile);
              expect(stat.isFile).to.equal(true);
            }
            return done();
          };
        })(this));
      });
      it('reads a JSON file into a string', function(done) {
        var jsonString;
        jsonString = '{"answer":42,"autoParse":false}';
        this.newFile = this.testFolder + "/json test file.json";
        return this.client.writeFile(this.newFile, jsonString, (function(_this) {
          return function(error, stat) {
            expect(error).to.equal(null);
            return _this.client.readFile(_this.newFile, function(error, data, stat) {
              expect(error).to.equal(null);
              expect(data).to.equal(jsonString);
              if (!Dropbox.Util.Xhr.ieXdr) {
                expect(stat).to.be.instanceOf(Dropbox.File.Stat);
                expect(stat.path).to.equal(_this.newFile);
                expect(stat.isFile).to.equal(true);
              }
              return done();
            });
          };
        })(this));
      });
      it('reads a binary file into a Blob', function(done) {
        if (typeof Blob === "undefined" || Blob === null) {
          return done();
        }
        return this.client.readFile(this.imageFile, {
          blob: true
        }, (function(_this) {
          return function(error, blob, stat) {
            var buffer, onBufferAvailable, reader;
            expect(error).to.equal(null);
            expect(blob).to.be.instanceOf(Blob);
            if (!Dropbox.Util.Xhr.ieXdr) {
              expect(stat).to.be.instanceOf(Dropbox.File.Stat);
              expect(stat.path).to.equal(_this.imageFile);
              expect(stat.isFile).to.equal(true);
              onBufferAvailable = function(buffer) {
                var bytes, i, view;
                view = new Uint8Array(buffer);
                bytes = (function() {
                  var j, ref, results;
                  results = [];
                  for (i = j = 0, ref = buffer.byteLength; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                    results.push(view[i]);
                  }
                  return results;
                })();
                expect(bytes).to.deep.equal(_this.imageFileBytes);
                return done();
              };
              if (typeof FileReaderSync !== 'undefined') {
                reader = new FileReaderSync;
                buffer = reader.readAsArrayBuffer(blob);
                return onBufferAvailable(buffer);
              } else {
                reader = new FileReader;
                reader.onloadend = function() {
                  if (reader.readyState !== FileReader.DONE) {
                    return;
                  }
                  return onBufferAvailable(reader.result);
                };
                return reader.readAsArrayBuffer(blob);
              }
            }
          };
        })(this));
      });
      it('reads a binary file into an ArrayBuffer', function(done) {
        if (typeof ArrayBuffer === "undefined" || ArrayBuffer === null) {
          return done();
        }
        return this.client.readFile(this.imageFile, {
          arrayBuffer: true
        }, (function(_this) {
          return function(error, buffer, stat) {
            var bytes, i, view;
            expect(error).to.equal(null);
            expect(buffer).to.be.instanceOf(ArrayBuffer);
            expect(buffer.byteLength).to.equal(_this.imageFileBytes.length);
            if (!Dropbox.Util.Xhr.ieXdr) {
              expect(stat).to.be.instanceOf(Dropbox.File.Stat);
              expect(stat.path).to.equal(_this.imageFile);
              expect(stat.isFile).to.equal(true);
            }
            view = new Uint8Array(buffer);
            bytes = (function() {
              var j, ref, results;
              results = [];
              for (i = j = 0, ref = buffer.byteLength; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                results.push(view[i]);
              }
              return results;
            })();
            expect(bytes).to.deep.equal(_this.imageFileBytes);
            return done();
          };
        })(this));
      });
      it('reads a binary file into a node.js Buffer', function(done) {
        if (typeof Buffer === "undefined" || Buffer === null) {
          return done();
        }
        return this.client.readFile(this.imageFile, {
          buffer: true
        }, (function(_this) {
          return function(error, buffer, stat) {
            var bytes, i;
            expect(error).to.equal(null);
            expect(buffer).to.be.instanceOf(Buffer);
            expect(stat).to.be.instanceOf(Dropbox.File.Stat);
            expect(stat.path).to.equal(_this.imageFile);
            expect(stat.isFile).to.equal(true);
            bytes = (function() {
              var j, ref, results;
              results = [];
              for (i = j = 0, ref = buffer.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                results.push(buffer.readUInt8(i));
              }
              return results;
            })();
            expect(bytes).to.deep.equal(_this.imageFileBytes);
            return done();
          };
        })(this));
      });
      it('reports non-existing files correctly', function(done) {
        return this.client.readFile(this.textFile + '-not-found', (function(_this) {
          return function(error, text, stat) {
            expect(text).not.to.be.ok;
            expect(stat).not.to.be.ok;
            expect(error).to.be.instanceOf(Dropbox.ApiError);
            if (!Dropbox.Util.Xhr.ieXdr) {
              expect(error.status).to.equal(Dropbox.ApiError.NOT_FOUND);
              expect(error.url).to.contain('-not-found');
            }
            return done();
          };
        })(this));
      });
      describe('with an onXhr listener', function() {
        beforeEach(function() {
          this.listenerXhr = null;
          return this.callbackCalled = false;
        });
        it('calls the listener with a Dropbox.Util.Xhr argument', function(done) {
          this.client.onXhr.addListener((function(_this) {
            return function(xhr) {
              expect(xhr).to.be.instanceOf(Dropbox.Util.Xhr);
              _this.listenerXhr = xhr;
              return true;
            };
          })(this));
          return this.client.readFile(this.textFile, (function(_this) {
            return function(error, data, stat) {
              expect(error).to.equal(null);
              expect(data).to.equal(_this.textFileData);
              return done();
            };
          })(this));
        });
        it('calls the listener before firing the XHR', function(done) {
          this.client.onXhr.addListener((function(_this) {
            return function(xhr) {
              if (!Dropbox.Util.Xhr.ieXdr) {
                expect(xhr.xhr.readyState).to.equal(1);
              }
              expect(_this.callbackCalled).to.equal(false);
              _this.listenerXhr = xhr;
              return true;
            };
          })(this));
          return this.client.readFile(this.textFile, (function(_this) {
            return function(error, data, stat) {
              _this.callbackCalled = true;
              expect(_this.listenerXhr).to.be.instanceOf(Dropbox.Util.Xhr);
              expect(error).to.equal(null);
              expect(data).to.equal(_this.textFileData);
              return done();
            };
          })(this));
        });
        return it('does not send the XHR if the listener cancels the event', function(done) {
          this.client.onXhr.addListener((function(_this) {
            return function(xhr) {
              expect(_this.callbackCalled).to.equal(false);
              _this.listenerXhr = xhr;
              xhr.send();
              return false;
            };
          })(this));
          return this.client.readFile(this.textFile, (function(_this) {
            return function(error, data, stat) {
              _this.callbackCalled = true;
              expect(_this.listenerXhr).to.be.instanceOf(Dropbox.Util.Xhr);
              return done();
            };
          })(this));
        });
      });
      return describe('with httpCache', function() {
        beforeEach(function() {
          this.xhr = null;
          return this.client.onXhr.addListener((function(_this) {
            return function(xhr) {
              return _this.xhr = xhr;
            };
          })(this));
        });
        return it('reads a text file using Authorization headers', function(done) {
          return this.client.readFile(this.textFile, {
            httpCache: true
          }, (function(_this) {
            return function(error, data, stat) {
              if (Dropbox.Util.Xhr.ieXdr) {
                expect(_this.xhr.url).to.contain('access_token');
              } else {
                expect(_this.xhr.headers).to.have.key('Authorization');
              }
              expect(error).to.equal(null);
              expect(data).to.equal(_this.textFileData);
              if (!Dropbox.Util.Xhr.ieXdr) {
                expect(stat).to.be.instanceOf(Dropbox.File.Stat);
                expect(stat.path).to.equal(_this.textFile);
                expect(stat.isFile).to.equal(true);
              }
              return done();
            };
          })(this));
        });
      });
    });
    describe('#writeFile', function() {
      beforeEach(function() {
        return this.newFile = null;
      });
      afterEach(function(done) {
        if (!this.newFile) {
          return done();
        }
        return this.client.remove(this.newFile, function(error, stat) {
          return done();
        });
      });
      it('writes a new text file', function(done) {
        this.newFile = this.testFolder + "/another text file.txt";
        this.newFileData = "Another plaintext file " + (Math.random().toString(36)) + ".";
        return this.client.writeFile(this.newFile, this.newFileData, (function(_this) {
          return function(error, stat) {
            expect(error).to.equal(null);
            expect(stat).to.be.instanceOf(Dropbox.File.Stat);
            expect(stat.path).to.equal(_this.newFile);
            expect(stat.isFile).to.equal(true);
            return _this.client.readFile(_this.newFile, function(error, data, stat) {
              expect(error).to.equal(null);
              expect(data).to.equal(_this.newFileData);
              if (!Dropbox.Util.Xhr.ieXdr) {
                expect(stat).to.be.instanceOf(Dropbox.File.Stat);
                expect(stat.path).to.equal(_this.newFile);
                expect(stat.isFile).to.equal(true);
              }
              return done();
            });
          };
        })(this));
      });
      it('writes a new empty file', function(done) {
        this.newFile = this.testFolder + "/another text file.txt";
        this.newFileData = '';
        return this.client.writeFile(this.newFile, this.newFileData, (function(_this) {
          return function(error, stat) {
            expect(error).to.equal(null);
            expect(stat).to.be.instanceOf(Dropbox.File.Stat);
            expect(stat.path).to.equal(_this.newFile);
            expect(stat.isFile).to.equal(true);
            return _this.client.readFile(_this.newFile, function(error, data, stat) {
              expect(error).to.equal(null);
              expect(data).to.equal(_this.newFileData);
              if (!Dropbox.Util.Xhr.ieXdr) {
                expect(stat).to.be.instanceOf(Dropbox.File.Stat);
                expect(stat.path).to.equal(_this.newFile);
                expect(stat.isFile).to.equal(true);
              }
              return done();
            });
          };
        })(this));
      });
      it('writes a new text file with ~ - and _ in the name', function(done) {
        this.newFile = this.testFolder + "/oauth~sig-test_file.txt";
        this.newFileData = "A file whose name checks for OAuth signatures on ~-_";
        return this.client.writeFile(this.newFile, this.newFileData, (function(_this) {
          return function(error, stat) {
            expect(error).to.equal(null);
            expect(stat).to.be.instanceOf(Dropbox.File.Stat);
            expect(stat.path).to.equal(_this.newFile);
            expect(stat.isFile).to.equal(true);
            return _this.client.readFile(_this.newFile, function(error, data, stat) {
              expect(error).to.equal(null);
              expect(data).to.equal(_this.newFileData);
              if (!Dropbox.Util.Xhr.ieXdr) {
                expect(stat).to.be.instanceOf(Dropbox.File.Stat);
                expect(stat.path).to.equal(_this.newFile);
                expect(stat.isFile).to.equal(true);
              }
              return done();
            });
          };
        })(this));
      });
      it('writes a Blob to a binary file', function(done) {
        var i, j, newBuffer, newBytes, ref;
        if (!((typeof Blob !== "undefined" && Blob !== null) && (typeof ArrayBuffer !== "undefined" && ArrayBuffer !== null))) {
          return done();
        }
        this.newFile = this.testFolder + "/test image from blob.png";
        newBuffer = new ArrayBuffer(this.imageFileBytes.length);
        newBytes = new Uint8Array(newBuffer);
        for (i = j = 0, ref = this.imageFileBytes.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          newBytes[i] = this.imageFileBytes[i];
        }
        this.newBlob = buildBlob([newBytes], {
          type: 'image/png'
        });
        if (this.newBlob.size !== newBuffer.byteLength) {
          this.newBlob = buildBlob([newBuffer], {
            type: 'image/png'
          });
        }
        return this.client.writeFile(this.newFile, this.newBlob, (function(_this) {
          return function(error, stat) {
            expect(error).to.equal(null);
            expect(stat).to.be.instanceOf(Dropbox.File.Stat);
            expect(stat.path).to.equal(_this.newFile);
            expect(stat.isFile).to.equal(true);
            expect(stat.size).to.equal(_this.newBlob.size);
            return _this.client.readFile(_this.newFile, {
              arrayBuffer: true
            }, function(error, buffer, stat) {
              var bytes, view;
              expect(error).to.equal(null);
              expect(buffer).to.be.instanceOf(ArrayBuffer);
              expect(stat).to.be.instanceOf(Dropbox.File.Stat);
              expect(stat.path).to.equal(_this.newFile);
              expect(stat.isFile).to.equal(true);
              view = new Uint8Array(buffer);
              bytes = (function() {
                var k, ref1, results;
                results = [];
                for (i = k = 0, ref1 = buffer.byteLength; 0 <= ref1 ? k < ref1 : k > ref1; i = 0 <= ref1 ? ++k : --k) {
                  results.push(view[i]);
                }
                return results;
              })();
              expect(bytes).to.deep.equal(_this.imageFileBytes);
              return done();
            });
          };
        })(this));
      });
      it('writes a File to a binary file', function(done) {
        var actualTestCase, file, i, j, newBlob, newBuffer, newBytes, noFileConstructorError, ref;
        if (!((typeof File !== "undefined" && File !== null) && (typeof Blob !== "undefined" && Blob !== null) && (typeof ArrayBuffer !== "undefined" && ArrayBuffer !== null))) {
          return done();
        }
        this.newFile = this.testFolder + "/test image from file.png";
        newBuffer = new ArrayBuffer(this.imageFileBytes.length);
        newBytes = new Uint8Array(newBuffer);
        for (i = j = 0, ref = this.imageFileBytes.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          newBytes[i] = this.imageFileBytes[i];
        }
        actualTestCase = (function(_this) {
          return function(file) {
            _this.newFileObject = file;
            return _this.client.writeFile(_this.newFile, _this.newFileObject, function(error, stat) {
              expect(error).to.equal(null);
              expect(stat).to.be.instanceOf(Dropbox.File.Stat);
              expect(stat.path).to.equal(_this.newFile);
              expect(stat.isFile).to.equal(true);
              expect(stat.size).to.equal(_this.newFileObject.size);
              return _this.client.readFile(_this.newFile, {
                arrayBuffer: true
              }, function(error, buffer, stat) {
                var bytes, view;
                expect(error).to.equal(null);
                expect(buffer).to.be.instanceOf(ArrayBuffer);
                expect(stat).to.be.instanceOf(Dropbox.File.Stat);
                expect(stat.path).to.equal(_this.newFile);
                expect(stat.isFile).to.equal(true);
                view = new Uint8Array(buffer);
                bytes = (function() {
                  var k, ref1, results;
                  results = [];
                  for (i = k = 0, ref1 = buffer.byteLength; 0 <= ref1 ? k < ref1 : k > ref1; i = 0 <= ref1 ? ++k : --k) {
                    results.push(view[i]);
                  }
                  return results;
                })();
                expect(bytes).to.deep.equal(_this.imageFileBytes);
                return done();
              });
            });
          };
        })(this);
        try {
          file = new File([newBuffer], 'test image file.png', {
            type: 'image/png'
          });
          return actualTestCase(file);
        } catch (_error) {
          noFileConstructorError = _error;
          newBlob = buildBlob([newBytes], {
            type: 'image/png'
          });
          if (typeof webkitRequestFileSystem === 'undefined') {
            return done();
          }
          return webkitRequestFileSystem(window.TEMPORARY, 1024 * 1024, function(fileSystem) {
            return fileSystem.root.getFile('test image file.png', {
              create: true,
              exclusive: false
            }, function(fileEntry) {
              return fileEntry.createWriter(function(fileWriter) {
                fileWriter.onwriteend = function() {
                  return fileEntry.file(function(file) {
                    return actualTestCase(file);
                  });
                };
                return fileWriter.write(newBlob);
              });
            });
          });
        }
      });
      it('writes an ArrayBuffer to a binary file', function(done) {
        var i, j, newBytes, ref;
        if (typeof ArrayBuffer === "undefined" || ArrayBuffer === null) {
          return done();
        }
        this.newFile = this.testFolder + "/test image from arraybuffer.png";
        this.newBuffer = new ArrayBuffer(this.imageFileBytes.length);
        newBytes = new Uint8Array(this.newBuffer);
        for (i = j = 0, ref = this.imageFileBytes.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          newBytes[i] = this.imageFileBytes[i];
        }
        return this.client.writeFile(this.newFile, this.newBuffer, (function(_this) {
          return function(error, stat) {
            expect(error).to.equal(null);
            expect(stat).to.be.instanceOf(Dropbox.File.Stat);
            expect(stat.path).to.equal(_this.newFile);
            expect(stat.isFile).to.equal(true);
            expect(stat.size).to.equal(_this.newBuffer.byteLength);
            return _this.client.readFile(_this.newFile, {
              arrayBuffer: true
            }, function(error, buffer, stat) {
              var bytes, view;
              expect(error).to.equal(null);
              expect(buffer).to.be.instanceOf(ArrayBuffer);
              expect(stat).to.be.instanceOf(Dropbox.File.Stat);
              expect(stat.path).to.equal(_this.newFile);
              expect(stat.isFile).to.equal(true);
              view = new Uint8Array(buffer);
              bytes = (function() {
                var k, ref1, results;
                results = [];
                for (i = k = 0, ref1 = buffer.byteLength; 0 <= ref1 ? k < ref1 : k > ref1; i = 0 <= ref1 ? ++k : --k) {
                  results.push(view[i]);
                }
                return results;
              })();
              expect(bytes).to.deep.equal(_this.imageFileBytes);
              return done();
            });
          };
        })(this));
      });
      it('writes an ArrayBufferView to a binary file', function(done) {
        var i, j, ref;
        if (typeof ArrayBuffer === "undefined" || ArrayBuffer === null) {
          return done();
        }
        this.newFile = this.testFolder + "/test image from arraybufferview.png";
        this.newBytes = new Uint8Array(this.imageFileBytes.length);
        for (i = j = 0, ref = this.imageFileBytes.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          this.newBytes[i] = this.imageFileBytes[i];
        }
        return this.client.writeFile(this.newFile, this.newBytes, (function(_this) {
          return function(error, stat) {
            expect(error).to.equal(null);
            expect(stat).to.be.instanceOf(Dropbox.File.Stat);
            expect(stat.path).to.equal(_this.newFile);
            expect(stat.isFile).to.equal(true);
            expect(stat.size).to.equal(_this.newBytes.byteLength);
            return _this.client.readFile(_this.newFile, {
              arrayBuffer: true
            }, function(error, buffer, stat) {
              var bytes, view;
              expect(error).to.equal(null);
              expect(buffer).to.be.instanceOf(ArrayBuffer);
              expect(stat).to.be.instanceOf(Dropbox.File.Stat);
              expect(stat.path).to.equal(_this.newFile);
              expect(stat.isFile).to.equal(true);
              view = new Uint8Array(buffer);
              bytes = (function() {
                var k, ref1, results;
                results = [];
                for (i = k = 0, ref1 = buffer.byteLength; 0 <= ref1 ? k < ref1 : k > ref1; i = 0 <= ref1 ? ++k : --k) {
                  results.push(view[i]);
                }
                return results;
              })();
              expect(bytes).to.deep.equal(_this.imageFileBytes);
              return done();
            });
          };
        })(this));
      });
      return it('writes a node.js Buffer to a binary file', function(done) {
        var i, j, ref;
        if (typeof Buffer === "undefined" || Buffer === null) {
          return done();
        }
        this.newFile = this.testFolder + "/test image from node buffer.png";
        this.newBuffer = new Buffer(this.imageFileBytes.length);
        for (i = j = 0, ref = this.imageFileBytes.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          this.newBuffer.writeUInt8(this.imageFileBytes[i], i);
        }
        return this.client.writeFile(this.newFile, this.newBuffer, (function(_this) {
          return function(error, stat) {
            expect(error).to.equal(null);
            expect(stat).to.be.instanceOf(Dropbox.File.Stat);
            expect(stat.path).to.equal(_this.newFile);
            expect(stat.isFile).to.equal(true);
            expect(stat.size).to.equal(_this.newBuffer.length);
            return _this.client.readFile(_this.newFile, {
              buffer: true
            }, function(error, buffer, stat) {
              var bytes;
              expect(error).to.equal(null);
              expect(buffer).to.be.instanceOf(Buffer);
              expect(stat).to.be.instanceOf(Dropbox.File.Stat);
              expect(stat.path).to.equal(_this.newFile);
              expect(stat.isFile).to.equal(true);
              bytes = (function() {
                var k, ref1, results;
                results = [];
                for (i = k = 0, ref1 = buffer.length; 0 <= ref1 ? k < ref1 : k > ref1; i = 0 <= ref1 ? ++k : --k) {
                  results.push(buffer.readUInt8(i));
                }
                return results;
              })();
              expect(bytes).to.deep.equal(_this.imageFileBytes);
              return done();
            });
          };
        })(this));
      });
    });
    describe('#resumableUploadStep + #resumableUploadFinish', function() {
      beforeEach(function() {
        var i, j, k, ref, ref1;
        if (typeof ArrayBuffer !== "undefined" && ArrayBuffer !== null) {
          this.length1 = Math.ceil(this.imageFileBytes.length / 3);
          this.length2 = this.imageFileBytes.length - this.length1;
          this.arrayBuffer1 = new ArrayBuffer(this.length1);
          if (typeof Buffer !== "undefined" && Buffer !== null) {
            this.buffer1 = new Buffer(this.length1);
          }
          this.view1 = new Uint8Array(this.arrayBuffer1);
          for (i = j = 0, ref = this.length1; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
            this.view1[i] = this.imageFileBytes[i];
            if (this.buffer1) {
              this.buffer1.writeUInt8(this.imageFileBytes[i], i);
            }
          }
          this.arrayBuffer2 = new ArrayBuffer(this.length2);
          if (typeof Buffer !== "undefined" && Buffer !== null) {
            this.buffer2 = new Buffer(this.length2);
          }
          this.view2 = new Uint8Array(this.arrayBuffer2);
          for (i = k = 0, ref1 = this.length2; 0 <= ref1 ? k < ref1 : k > ref1; i = 0 <= ref1 ? ++k : --k) {
            this.view2[i] = this.imageFileBytes[this.length1 + i];
            if (this.buffer2) {
              this.buffer2.writeUInt8(this.imageFileBytes[this.length1 + i], i);
            }
          }
          if (typeof Blob !== "undefined" && Blob !== null) {
            this.blob1 = buildBlob([this.view1], {
              type: 'image/png'
            });
            if (this.blob1.size !== this.arrayBuffer1.byteLength) {
              this.blob1 = buildBlob([this.arrayBuffer1], {
                type: 'image/png'
              });
            }
            this.blob2 = buildBlob([this.view2], {
              type: 'image/png'
            });
            if (this.blob2.size !== this.arrayBuffer2.byteLength) {
              return this.blob2 = buildBlob([this.arrayBuffer2], {
                type: 'image/png'
              });
            }
          }
        }
      });
      afterEach(function(done) {
        this.timeout(30 * 1000);
        if (!this.newFile) {
          return done();
        }
        return this.client.remove(this.newFile, function(error, stat) {
          return done();
        });
      });
      it('writes a text file in two stages', function(done) {
        var line1, line2;
        this.timeout(20 * 1000);
        this.newFile = this.testFolder + "/test resumable upload.txt";
        line1 = "This is the first fragment\n";
        line2 = "This is the second fragment\n";
        return this.client.resumableUploadStep(line1, null, (function(_this) {
          return function(error, cursor1) {
            expect(error).to.equal(null);
            expect(cursor1).to.be.instanceOf(Dropbox.Http.UploadCursor);
            expect(cursor1.offset).to.equal(line1.length);
            return _this.client.resumableUploadStep(line2, cursor1, function(error, cursor2) {
              expect(error).to.equal(null);
              expect(cursor2).to.be.instanceOf(Dropbox.Http.UploadCursor);
              expect(cursor2.offset).to.equal(line1.length + line2.length);
              expect(cursor2.tag).to.equal(cursor1.tag);
              return _this.client.resumableUploadFinish(_this.newFile, cursor2, function(error, stat) {
                expect(error).to.equal(null);
                expect(stat).to.be.instanceOf(Dropbox.File.Stat);
                expect(stat.path).to.equal(_this.newFile);
                expect(stat.isFile).to.equal(true);
                return _this.client.readFile(_this.newFile, function(error, data, stat) {
                  expect(error).to.equal(null);
                  expect(data).to.equal(line1 + line2);
                  if (!Dropbox.Util.Xhr.ieXdr) {
                    expect(stat).to.be.instanceOf(Dropbox.File.Stat);
                    expect(stat.path).to.equal(_this.newFile);
                    expect(stat.isFile).to.equal(true);
                  }
                  return done();
                });
              });
            });
          };
        })(this));
      });
      it('writes a binary file using two ArrayBuffers', function(done) {
        if (!this.arrayBuffer1) {
          return done();
        }
        this.timeout(20 * 1000);
        this.newFile = this.testFolder + "/test resumable arraybuffer upload.png";
        return this.client.resumableUploadStep(this.arrayBuffer1, null, (function(_this) {
          return function(error, cursor1) {
            expect(error).to.equal(null);
            expect(cursor1).to.be.instanceOf(Dropbox.Http.UploadCursor);
            expect(cursor1.offset).to.equal(_this.length1);
            return _this.client.resumableUploadStep(_this.arrayBuffer2, cursor1, function(error, cursor2) {
              expect(error).to.equal(null);
              expect(cursor2).to.be.instanceOf(Dropbox.Http.UploadCursor);
              expect(cursor2.offset).to.equal(_this.length1 + _this.length2);
              expect(cursor2.tag).to.equal(cursor1.tag);
              return _this.client.resumableUploadFinish(_this.newFile, cursor2, function(error, stat) {
                expect(error).to.equal(null);
                expect(stat).to.be.instanceOf(Dropbox.File.Stat);
                expect(stat.path).to.equal(_this.newFile);
                expect(stat.isFile).to.equal(true);
                return _this.client.readFile(_this.newFile, {
                  arrayBuffer: true
                }, function(error, buffer, stat) {
                  var bytes, i, view;
                  expect(error).to.equal(null);
                  expect(buffer).to.be.instanceOf(ArrayBuffer);
                  expect(stat).to.be.instanceOf(Dropbox.File.Stat);
                  expect(stat.path).to.equal(_this.newFile);
                  expect(stat.isFile).to.equal(true);
                  view = new Uint8Array(buffer);
                  bytes = (function() {
                    var j, ref, results;
                    results = [];
                    for (i = j = 0, ref = buffer.byteLength; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                      results.push(view[i]);
                    }
                    return results;
                  })();
                  expect(bytes).to.deep.equal(_this.imageFileBytes);
                  return done();
                });
              });
            });
          };
        })(this));
      });
      it('writes a binary file using two ArrayBufferViews', function(done) {
        if (!this.view1) {
          return done();
        }
        this.timeout(20 * 1000);
        this.newFile = this.testFolder + "/test resumable arraybuffer upload.png";
        return this.client.resumableUploadStep(this.arrayBuffer1, null, (function(_this) {
          return function(error, cursor1) {
            expect(error).to.equal(null);
            expect(cursor1).to.be.instanceOf(Dropbox.Http.UploadCursor);
            expect(cursor1.offset).to.equal(_this.length1);
            return _this.client.resumableUploadStep(_this.arrayBuffer2, cursor1, function(error, cursor2) {
              expect(error).to.equal(null);
              expect(cursor2).to.be.instanceOf(Dropbox.Http.UploadCursor);
              expect(cursor2.offset).to.equal(_this.length1 + _this.length2);
              expect(cursor2.tag).to.equal(cursor1.tag);
              return _this.client.resumableUploadFinish(_this.newFile, cursor2, function(error, stat) {
                expect(error).to.equal(null);
                expect(stat).to.be.instanceOf(Dropbox.File.Stat);
                expect(stat.path).to.equal(_this.newFile);
                expect(stat.isFile).to.equal(true);
                return _this.client.readFile(_this.newFile, {
                  arrayBuffer: true
                }, function(error, buffer, stat) {
                  var bytes, i, view;
                  expect(error).to.equal(null);
                  expect(buffer).to.be.instanceOf(ArrayBuffer);
                  expect(stat).to.be.instanceOf(Dropbox.File.Stat);
                  expect(stat.path).to.equal(_this.newFile);
                  expect(stat.isFile).to.equal(true);
                  view = new Uint8Array(buffer);
                  bytes = (function() {
                    var j, ref, results;
                    results = [];
                    for (i = j = 0, ref = buffer.byteLength; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                      results.push(view[i]);
                    }
                    return results;
                  })();
                  expect(bytes).to.deep.equal(_this.imageFileBytes);
                  return done();
                });
              });
            });
          };
        })(this));
      });
      it('writes a binary file using two node.js Buffers', function(done) {
        if (!this.buffer1) {
          return done();
        }
        this.timeout(30 * 1000);
        this.newFile = this.testFolder + "/test resumable node buffer upload.png";
        return this.client.resumableUploadStep(this.buffer1, null, (function(_this) {
          return function(error, cursor1) {
            expect(error).to.equal(null);
            expect(cursor1).to.be.instanceOf(Dropbox.Http.UploadCursor);
            expect(cursor1.offset).to.equal(_this.length1);
            return _this.client.resumableUploadStep(_this.buffer2, cursor1, function(error, cursor2) {
              expect(error).to.equal(null);
              expect(cursor2).to.be.instanceOf(Dropbox.Http.UploadCursor);
              expect(cursor2.offset).to.equal(_this.length1 + _this.length2);
              expect(cursor2.tag).to.equal(cursor1.tag);
              return _this.client.resumableUploadFinish(_this.newFile, cursor2, function(error, stat) {
                expect(error).to.equal(null);
                expect(stat).to.be.instanceOf(Dropbox.File.Stat);
                expect(stat.path).to.equal(_this.newFile);
                expect(stat.isFile).to.equal(true);
                return _this.client.readFile(_this.newFile, {
                  buffer: true
                }, function(error, buffer, stat) {
                  var bytes, i;
                  expect(error).to.equal(null);
                  expect(buffer).to.be.instanceOf(Buffer);
                  expect(stat).to.be.instanceOf(Dropbox.File.Stat);
                  expect(stat.path).to.equal(_this.newFile);
                  expect(stat.isFile).to.equal(true);
                  bytes = (function() {
                    var j, ref, results;
                    results = [];
                    for (i = j = 0, ref = buffer.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                      results.push(buffer.readUInt8(i));
                    }
                    return results;
                  })();
                  expect(bytes).to.deep.equal(_this.imageFileBytes);
                  return done();
                });
              });
            });
          };
        })(this));
      });
      it('writes a binary file using two Blobs', function(done) {
        if (!this.blob1) {
          return done();
        }
        this.timeout(20 * 1000);
        this.newFile = this.testFolder + "/test resumable blob upload.png";
        return this.client.resumableUploadStep(this.blob1, null, (function(_this) {
          return function(error, cursor1) {
            expect(error).to.equal(null);
            expect(cursor1).to.be.instanceOf(Dropbox.Http.UploadCursor);
            expect(cursor1.offset).to.equal(_this.length1);
            return _this.client.resumableUploadStep(_this.blob2, cursor1, function(error, cursor2) {
              expect(error).to.equal(null);
              expect(cursor2).to.be.instanceOf(Dropbox.Http.UploadCursor);
              expect(cursor2.offset).to.equal(_this.length1 + _this.length2);
              expect(cursor2.tag).to.equal(cursor1.tag);
              return _this.client.resumableUploadFinish(_this.newFile, cursor2, function(error, stat) {
                expect(error).to.equal(null);
                expect(stat).to.be.instanceOf(Dropbox.File.Stat);
                expect(stat.path).to.equal(_this.newFile);
                expect(stat.isFile).to.equal(true);
                return _this.client.readFile(_this.newFile, {
                  arrayBuffer: true
                }, function(error, buffer, stat) {
                  var bytes, i, view;
                  expect(error).to.equal(null);
                  expect(buffer).to.be.instanceOf(ArrayBuffer);
                  expect(stat).to.be.instanceOf(Dropbox.File.Stat);
                  expect(stat.path).to.equal(_this.newFile);
                  expect(stat.isFile).to.equal(true);
                  view = new Uint8Array(buffer);
                  bytes = (function() {
                    var j, ref, results;
                    results = [];
                    for (i = j = 0, ref = buffer.byteLength; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                      results.push(view[i]);
                    }
                    return results;
                  })();
                  expect(bytes).to.deep.equal(_this.imageFileBytes);
                  return done();
                });
              });
            });
          };
        })(this));
      });
      it('recovers from out-of-sync correctly', function(done) {
        var line1, line2;
        if (Dropbox.Util.Xhr.ieXdr) {
          return done();
        }
        this.timeout(20 * 1000);
        this.newFile = this.testFolder + "/test resumable upload out of sync.txt";
        line1 = "This is the first fragment\n";
        line2 = "This is the second fragment\n";
        return this.client.resumableUploadStep(line1, null, (function(_this) {
          return function(error, cursor1) {
            expect(error).to.equal(null);
            expect(cursor1).to.be.instanceOf(Dropbox.Http.UploadCursor);
            expect(cursor1.offset).to.equal(line1.length);
            cursor1.offset += 10;
            return _this.client.resumableUploadStep(line2, cursor1, function(error, cursor2) {
              expect(error).to.equal(null);
              expect(cursor2).to.be.instanceOf(Dropbox.Http.UploadCursor);
              expect(cursor2.offset).to.equal(line1.length);
              expect(cursor2.tag).to.equal(cursor1.tag);
              return _this.client.resumableUploadStep(line2, cursor2, function(error, cursor3) {
                expect(error).to.equal(null);
                expect(cursor3).to.be.instanceOf(Dropbox.Http.UploadCursor);
                expect(cursor3.offset).to.equal(line1.length + line2.length);
                expect(cursor3.tag).to.equal(cursor1.tag);
                return _this.client.resumableUploadFinish(_this.newFile, cursor3, function(error, stat) {
                  expect(error).to.equal(null);
                  expect(stat).to.be.instanceOf(Dropbox.File.Stat);
                  expect(stat.path).to.equal(_this.newFile);
                  expect(stat.isFile).to.equal(true);
                  return _this.client.readFile(_this.newFile, function(error, data, stat) {
                    expect(error).to.equal(null);
                    expect(data).to.equal(line1 + line2);
                    if (!Dropbox.Util.Xhr.ieXdr) {
                      expect(stat).to.be.instanceOf(Dropbox.File.Stat);
                      expect(stat.path).to.equal(_this.newFile);
                      expect(stat.isFile).to.equal(true);
                    }
                    return done();
                  });
                });
              });
            });
          };
        })(this));
      });
      return it('reports errors correctly', function(done) {
        var badCursor;
        this.newFile = this.testFolder + "/test resumable upload error.txt";
        badCursor = new Dropbox.Http.UploadCursor('trollcursor');
        badCursor.offset = 42;
        return this.client.resumableUploadStep(this.textFileData, badCursor, (function(_this) {
          return function(error, cursor) {
            expect(cursor).to.equal(void 0);
            expect(error).to.be.instanceOf(Dropbox.ApiError);
            if (!Dropbox.Util.Xhr.ieXdr) {
              expect(error.status).to.equal(Dropbox.ApiError.NOT_FOUND);
            }
            return done();
          };
        })(this));
      });
    });
    describe('#stat', function() {
      it('retrieves a Stat for a file', function(done) {
        return this.client.stat(this.textFile, (function(_this) {
          return function(error, stat) {
            expect(error).to.equal(null);
            expect(stat).to.be.instanceOf(Dropbox.File.Stat);
            expect(stat.path).to.equal(_this.textFile);
            expect(stat.isFile).to.equal(true);
            expect(stat.versionTag).to.equal(_this.textFileTag);
            expect(stat.size).to.equal(_this.textFileData.length);
            if (clientKeys.key === testFullDropboxKeys.key) {
              expect(stat.inAppFolder).to.equal(false);
            } else {
              expect(stat.inAppFolder).to.equal(true);
            }
            return done();
          };
        })(this));
      });
      it('retrieves a Stat for a folder', function(done) {
        return this.client.stat(this.testFolder, (function(_this) {
          return function(error, stat, entries) {
            expect(error).to.equal(null);
            expect(stat).to.be.instanceOf(Dropbox.File.Stat);
            expect(stat.path).to.equal(_this.testFolder);
            expect(stat.isFolder).to.equal(true);
            expect(stat.size).to.equal(0);
            if (clientKeys.key === testFullDropboxKeys.key) {
              expect(stat.inAppFolder).to.equal(false);
            } else {
              expect(stat.inAppFolder).to.equal(true);
            }
            expect(entries).to.equal(void 0);
            return done();
          };
        })(this));
      });
      it('retrieves a Stat and entries for a folder', function(done) {
        return this.client.stat(this.testFolder, {
          readDir: true
        }, (function(_this) {
          return function(error, stat, entries) {
            expect(error).to.equal(null);
            expect(stat).to.be.instanceOf(Dropbox.File.Stat);
            expect(stat.path).to.equal(_this.testFolder);
            expect(stat.isFolder).to.equal(true);
            expect(entries).to.be.ok;
            expect(entries).to.have.length(2);
            expect(entries[0]).to.be.instanceOf(Dropbox.File.Stat);
            expect(entries[0].path).not.to.equal(_this.testFolder);
            expect(entries[0].path).to.have.string(_this.testFolder);
            return done();
          };
        })(this));
      });
      it('fails cleanly for a non-existing path', function(done) {
        var listenerError;
        listenerError = null;
        this.client.onError.addListener(function(error) {
          return listenerError = error;
        });
        return this.client.stat(this.testFolder + '/should_404.txt', (function(_this) {
          return function(error, stat, entries) {
            expect(stat).to.equal(void 0);
            expect(entries).to.equal["null"];
            expect(error).to.be.instanceOf(Dropbox.ApiError);
            expect(listenerError).to.equal(error);
            if (!Dropbox.Util.Xhr.ieXdr) {
              expect(error).to.have.property('status');
              expect(error.status).to.equal(Dropbox.ApiError.NOT_FOUND);
            }
            return done();
          };
        })(this));
      });
      return describe('with httpCache', function() {
        beforeEach(function() {
          this.xhr = null;
          return this.client.onXhr.addListener((function(_this) {
            return function(xhr) {
              return _this.xhr = xhr;
            };
          })(this));
        });
        return it('retrieves a Stat for a file using Authorization headers', function(done) {
          return this.client.stat(this.textFile, {
            httpCache: true
          }, (function(_this) {
            return function(error, stat) {
              if (Dropbox.Util.Xhr.ieXdr) {
                expect(_this.xhr.url).to.contain('access_token');
              } else {
                expect(_this.xhr.headers).to.have.key('Authorization');
              }
              expect(error).to.equal(null);
              expect(stat).to.be.instanceOf(Dropbox.File.Stat);
              expect(stat.path).to.equal(_this.textFile);
              expect(stat.isFile).to.equal(true);
              expect(stat.versionTag).to.equal(_this.textFileTag);
              expect(stat.size).to.equal(_this.textFileData.length);
              if (clientKeys.key === testFullDropboxKeys.key) {
                expect(stat.inAppFolder).to.equal(false);
              } else {
                expect(stat.inAppFolder).to.equal(true);
              }
              return done();
            };
          })(this));
        });
      });
    });
    describe('#readdir', function() {
      it('retrieves a Stat and entries for a folder', function(done) {
        return this.client.readdir(this.testFolder, (function(_this) {
          return function(error, entries, dirStat, entryStats) {
            expect(error).to.equal(null);
            expect(entries).to.be.ok;
            expect(entries).to.have.length(2);
            expect(entries[0]).to.be.a('string');
            expect(entries[0]).not.to.have.string('/');
            expect(entries[0]).to.match(/^(test-binary-image.png)|(test-file.txt)$/);
            expect(dirStat).to.be.instanceOf(Dropbox.File.Stat);
            expect(dirStat.path).to.equal(_this.testFolder);
            expect(dirStat.isFolder).to.equal(true);
            if (clientKeys.key === testFullDropboxKeys.key) {
              expect(dirStat.inAppFolder).to.equal(false);
            } else {
              expect(dirStat.inAppFolder).to.equal(true);
            }
            expect(entryStats).to.be.ok;
            expect(entryStats).to.have.length(2);
            expect(entryStats[0]).to.be.instanceOf(Dropbox.File.Stat);
            expect(entryStats[0].path).not.to.equal(_this.testFolder);
            expect(entryStats[0].path).to.have.string(_this.testFolder);
            return done();
          };
        })(this));
      });
      describe('with httpCache', function() {
        beforeEach(function() {
          this.xhr = null;
          return this.client.onXhr.addListener((function(_this) {
            return function(xhr) {
              return _this.xhr = xhr;
            };
          })(this));
        });
        return it('retrieves a folder Stat and entries using Authorization', function(done) {
          return this.client.readdir(this.testFolder, {
            httpCache: true
          }, (function(_this) {
            return function(error, entries, dir_stat, entry_stats) {
              if (Dropbox.Util.Xhr.ieXdr) {
                expect(_this.xhr.url).to.contain('access_token');
              } else {
                expect(_this.xhr.headers).to.have.key('Authorization');
              }
              expect(error).to.equal(null);
              expect(entries).to.be.ok;
              expect(entries).to.have.length(2);
              expect(entries[0]).to.be.a('string');
              expect(entries[0]).not.to.have.string('/');
              expect(entries[0]).to.match(/^(test-binary-image.png)|(test-file.txt)$/);
              expect(dir_stat).to.be.instanceOf(Dropbox.File.Stat);
              expect(dir_stat.path).to.equal(_this.testFolder);
              expect(dir_stat.isFolder).to.equal(true);
              expect(entry_stats).to.be.ok;
              expect(entry_stats).to.have.length(2);
              expect(entry_stats[0]).to.be.instanceOf(Dropbox.File.Stat);
              expect(entry_stats[0].path).not.to.equal(_this.testFolder);
              expect(entry_stats[0].path).to.have.string(_this.testFolder);
              return done();
            };
          })(this));
        });
      });
      return describe('with contentHash', function(done) {
        beforeEach(function(done) {
          return this.client.readdir(this.testFolder, (function(_this) {
            return function(error, entries, dirStat) {
              expect(error).to.equal(null);
              _this.contentHash = dirStat.contentHash;
              return done();
            };
          })(this));
        });
        return it('does not retrieve a folder twice if the tag matches', function(done) {
          return this.client.readdir(this.testFolder, {
            contentHash: this.contentHash
          }, function(error, entries) {
            expect(error).to.be.instanceOf(Dropbox.ApiError);
            expect(entries).not.to.be.ok;
            if (!Dropbox.Util.Xhr.ieXdr) {
              expect(error.status).to.equal(Dropbox.ApiError.NO_CONTENT);
            }
            return done();
          });
        });
      });
    });
    describe('#history', function() {
      it('gets a list of revisions', function(done) {
        return this.client.history(this.textFile, (function(_this) {
          return function(error, versions) {
            expect(error).to.equal(null);
            expect(versions).to.have.length(1);
            expect(versions[0]).to.be.instanceOf(Dropbox.File.Stat);
            expect(versions[0].path).to.equal(_this.textFile);
            expect(versions[0].size).to.equal(_this.textFileData.length);
            expect(versions[0].versionTag).to.equal(_this.textFileTag);
            return done();
          };
        })(this));
      });
      it('returns 40x if the limit is set to 0', function(done) {
        var listenerError;
        listenerError = null;
        this.client.onError.addListener(function(error) {
          return listenerError = error;
        });
        return this.client.history(this.textFile, {
          limit: 0
        }, (function(_this) {
          return function(error, versions) {
            expect(error).to.be.instanceOf(Dropbox.ApiError);
            expect(listenerError).to.equal(error);
            if (!Dropbox.Util.Xhr.ieXdr) {
              expect(error.status).to.be.within(400, 499);
            }
            expect(versions).not.to.be.ok;
            return done();
          };
        })(this));
      });
      return describe('with httpCache', function() {
        beforeEach(function() {
          this.xhr = null;
          return this.client.onXhr.addListener((function(_this) {
            return function(xhr) {
              return _this.xhr = xhr;
            };
          })(this));
        });
        return it('gets a list of revisions using Authorization headers', function(done) {
          return this.client.history(this.textFile, {
            httpCache: true
          }, (function(_this) {
            return function(error, versions) {
              if (Dropbox.Util.Xhr.ieXdr) {
                expect(_this.xhr.url).to.contain('access_token');
              } else {
                expect(_this.xhr.headers).to.have.key('Authorization');
              }
              expect(error).to.equal(null);
              expect(versions).to.have.length(1);
              expect(versions[0]).to.be.instanceOf(Dropbox.File.Stat);
              expect(versions[0].path).to.equal(_this.textFile);
              expect(versions[0].size).to.equal(_this.textFileData.length);
              expect(versions[0].versionTag).to.equal(_this.textFileTag);
              return done();
            };
          })(this));
        });
      });
    });
    describe('#copy', function() {
      beforeEach(function() {
        return this.newFile = null;
      });
      afterEach(function(done) {
        if (!this.newFile) {
          return done();
        }
        return this.client.remove(this.newFile, function(error, stat) {
          return done();
        });
      });
      return it('copies a file given by path', function(done) {
        this.newFile = this.testFolder + "/copy of test-file.txt";
        return this.client.copy(this.textFile, this.newFile, (function(_this) {
          return function(error, stat) {
            expect(error).to.equal(null);
            expect(stat).to.be.instanceOf(Dropbox.File.Stat);
            expect(stat.path).to.equal(_this.newFile);
            if (clientKeys.key === testFullDropboxKeys.key) {
              expect(stat.inAppFolder).to.equal(false);
            } else {
              expect(stat.inAppFolder).to.equal(true);
            }
            return _this.client.readFile(_this.newFile, function(error, data, stat) {
              expect(error).to.equal(null);
              expect(data).to.equal(_this.textFileData);
              if (!Dropbox.Util.Xhr.ieXdr) {
                expect(stat).to.be.instanceOf(Dropbox.File.Stat);
                expect(stat.path).to.equal(_this.newFile);
              }
              return _this.client.readFile(_this.textFile, function(error, data, stat) {
                expect(error).to.equal(null);
                expect(data).to.equal(_this.textFileData);
                if (!Dropbox.Util.Xhr.ieXdr) {
                  expect(stat).to.be.instanceOf(Dropbox.File.Stat);
                  expect(stat.path).to.equal(_this.textFile);
                  expect(stat.versionTag).to.equal(_this.textFileTag);
                }
                return done();
              });
            });
          };
        })(this));
      });
    });
    describe('#makeCopyReference', function() {
      beforeEach(function() {
        return this.newFile = null;
      });
      afterEach(function(done) {
        if (!this.newFile) {
          return done();
        }
        return this.client.remove(this.newFile, function(error, stat) {
          return done();
        });
      });
      return it('creates a Dropbox.File.CopyReference that copies the file', function(done) {
        this.newFile = this.testFolder + "/ref copy of test-file.txt";
        return this.client.makeCopyReference(this.textFile, (function(_this) {
          return function(error, copyRef) {
            expect(error).to.equal(null);
            expect(copyRef).to.be.instanceOf(Dropbox.File.CopyReference);
            return _this.client.copy(copyRef, _this.newFile, function(error, stat) {
              expect(error).to.equal(null);
              expect(stat).to.be.instanceOf(Dropbox.File.Stat);
              expect(stat.path).to.equal(_this.newFile);
              expect(stat.isFile).to.equal(true);
              return _this.client.readFile(_this.newFile, function(error, data, stat) {
                expect(error).to.equal(null);
                expect(data).to.equal(_this.textFileData);
                if (!Dropbox.Util.Xhr.ieXdr) {
                  expect(stat).to.be.instanceOf(Dropbox.File.Stat);
                  expect(stat.path).to.equal(_this.newFile);
                }
                return done();
              });
            });
          };
        })(this));
      });
    });
    describe('#move', function() {
      beforeEach(function(done) {
        this.moveFrom = this.testFolder + "/move source of test-file.txt";
        this.moveTo = null;
        return this.client.copy(this.textFile, this.moveFrom, function(error, stat) {
          expect(error).to.equal(null);
          return done();
        });
      });
      afterEach(function(done) {
        return this.client.remove(this.moveFrom, (function(_this) {
          return function(error, stat) {
            if (!_this.moveTo) {
              return done();
            }
            return _this.client.remove(_this.moveTo, function(error, stat) {
              return done();
            });
          };
        })(this));
      });
      return it('moves a file', function(done) {
        this.moveTo = this.testFolder + "/moved test-file.txt";
        return this.client.move(this.moveFrom, this.moveTo, (function(_this) {
          return function(error, stat) {
            expect(error).to.equal(null);
            expect(stat).to.be.instanceOf(Dropbox.File.Stat);
            expect(stat.path).to.equal(_this.moveTo);
            expect(stat.isFile).to.equal(true);
            if (clientKeys.key === testFullDropboxKeys.key) {
              expect(stat.inAppFolder).to.equal(false);
            } else {
              expect(stat.inAppFolder).to.equal(true);
            }
            return _this.client.readFile(_this.moveTo, function(error, data, stat) {
              expect(error).to.equal(null);
              expect(data).to.equal(_this.textFileData);
              if (!Dropbox.Util.Xhr.ieXdr) {
                expect(stat).to.be.instanceOf(Dropbox.File.Stat);
                expect(stat.path).to.equal(_this.moveTo);
              }
              return _this.client.readFile(_this.moveFrom, function(error, data, stat) {
                expect(error).to.be.ok;
                if (!Dropbox.Util.Xhr.ieXdr) {
                  expect(error).to.have.property('status');
                  expect(error.status).to.equal(Dropbox.ApiError.NOT_FOUND);
                }
                expect(data).to.equal(void 0);
                if (!Dropbox.Util.Xhr.ieXdr) {
                  expect(stat).to.equal(void 0);
                }
                return done();
              });
            });
          };
        })(this));
      });
    });
    describe('#remove', function() {
      beforeEach(function(done) {
        this.newFolder = this.testFolder + "/folder delete test";
        return this.client.mkdir(this.newFolder, (function(_this) {
          return function(error, stat) {
            expect(error).to.equal(null);
            return done();
          };
        })(this));
      });
      afterEach(function(done) {
        if (!this.newFolder) {
          return done();
        }
        return this.client.remove(this.newFolder, function(error, stat) {
          return done();
        });
      });
      it('deletes a folder', function(done) {
        return this.client.remove(this.newFolder, (function(_this) {
          return function(error, stat) {
            expect(error).to.equal(null);
            expect(stat).to.be.instanceOf(Dropbox.File.Stat);
            expect(stat.path).to.equal(_this.newFolder);
            if (clientKeys.key === testFullDropboxKeys.key) {
              expect(stat.inAppFolder).to.equal(false);
            } else {
              expect(stat.inAppFolder).to.equal(true);
            }
            return _this.client.stat(_this.newFolder, {
              removed: true
            }, function(error, stat) {
              expect(error).to.equal(null);
              expect(stat).to.be.instanceOf(Dropbox.File.Stat);
              expect(stat.isRemoved).to.equal(true);
              return done();
            });
          };
        })(this));
      });
      return it('deletes a folder when called as unlink', function(done) {
        return this.client.unlink(this.newFolder, (function(_this) {
          return function(error, stat) {
            expect(error).to.equal(null);
            expect(stat).to.be.instanceOf(Dropbox.File.Stat);
            expect(stat.path).to.equal(_this.newFolder);
            return _this.client.stat(_this.newFolder, {
              removed: true
            }, function(error, stat) {
              expect(error).to.equal(null);
              expect(stat).to.be.instanceOf(Dropbox.File.Stat);
              expect(stat.isRemoved).to.equal(true);
              return done();
            });
          };
        })(this));
      });
    });
    describe('#revertFile', function() {
      return describe('on a removed file', function() {
        beforeEach(function(done) {
          this.newFile = this.testFolder + "/file revert test.txt";
          return this.client.copy(this.textFile, this.newFile, (function(_this) {
            return function(error, stat) {
              expect(error).to.equal(null);
              expect(stat).to.be.instanceOf(Dropbox.File.Stat);
              expect(stat.path).to.equal(_this.newFile);
              _this.versionTag = stat.versionTag;
              return _this.client.remove(_this.newFile, function(error, stat) {
                expect(error).to.equal(null);
                expect(stat).to.be.instanceOf(Dropbox.File.Stat);
                expect(stat.path).to.equal(_this.newFile);
                return done();
              });
            };
          })(this));
        });
        afterEach(function(done) {
          if (!this.newFile) {
            return done();
          }
          return this.client.remove(this.newFile, function(error, stat) {
            return done();
          });
        });
        return it('reverts the file to a previous version', function(done) {
          return this.client.revertFile(this.newFile, this.versionTag, (function(_this) {
            return function(error, stat) {
              expect(error).to.equal(null);
              expect(stat).to.be.instanceOf(Dropbox.File.Stat);
              expect(stat.path).to.equal(_this.newFile);
              expect(stat.isRemoved).to.equal(false);
              return _this.client.readFile(_this.newFile, function(error, data, stat) {
                expect(error).to.equal(null);
                expect(data).to.equal(_this.textFileData);
                if (!Dropbox.Util.Xhr.ieXdr) {
                  expect(stat).to.be.instanceOf(Dropbox.File.Stat);
                  expect(stat.path).to.equal(_this.newFile);
                  expect(stat.isRemoved).to.equal(false);
                }
                return done();
              });
            };
          })(this));
        });
      });
    });
    describe('#findByName', function() {
      it('locates the test folder given a partial name', function(done) {
        var namePattern;
        namePattern = this.testFolder.substring(5);
        return this.client.search('/', namePattern, (function(_this) {
          return function(error, matches) {
            expect(error).to.equal(null);
            expect(matches).to.have.length(1);
            expect(matches[0]).to.be.instanceOf(Dropbox.File.Stat);
            expect(matches[0].path).to.equal(_this.testFolder);
            expect(matches[0].isFolder).to.equal(true);
            return done();
          };
        })(this));
      });
      it('lists the test folder files given the "test" pattern', function(done) {
        return this.client.search(this.testFolder, 'test', (function(_this) {
          return function(error, matches) {
            expect(error).to.equal(null);
            expect(matches).to.have.length(2);
            return done();
          };
        })(this));
      });
      it('only lists one match when given limit 1', function(done) {
        return this.client.search(this.testFolder, 'test', {
          limit: 1
        }, (function(_this) {
          return function(error, matches) {
            expect(error).to.equal(null);
            expect(matches).to.have.length(1);
            return done();
          };
        })(this));
      });
      return describe('with httpCache', function() {
        beforeEach(function() {
          this.xhr = null;
          return this.client.onXhr.addListener((function(_this) {
            return function(xhr) {
              return _this.xhr = xhr;
            };
          })(this));
        });
        return it('locates the test folder using Authorization headers', function(done) {
          var namePattern;
          namePattern = this.testFolder.substring(5);
          return this.client.search('/', namePattern, {
            httpCache: true
          }, (function(_this) {
            return function(error, matches) {
              if (Dropbox.Util.Xhr.ieXdr) {
                expect(_this.xhr.url).to.contain('access_token');
              } else {
                expect(_this.xhr.headers).to.have.key('Authorization');
              }
              expect(error).to.equal(null);
              expect(matches).to.have.length(1);
              expect(matches[0]).to.be.instanceOf(Dropbox.File.Stat);
              expect(matches[0].path).to.equal(_this.testFolder);
              expect(matches[0].isFolder).to.equal(true);
              return done();
            };
          })(this));
        });
      });
    });
    describe('#makeUrl', function() {
      describe('for a short Web URL', function() {
        it('returns a shortened Dropbox URL', function(done) {
          return this.client.makeUrl(this.textFile, function(error, urlInfo) {
            expect(error).to.equal(null);
            expect(urlInfo).to.be.instanceOf(Dropbox.File.ShareUrl);
            expect(urlInfo.isDirect).to.equal(false);
            expect(urlInfo.url).to.contain('//db.tt/');
            return done();
          });
        });
        return it('returns a shortened Dropbox URL when given empty options', function(done) {
          return this.client.makeUrl(this.textFile, {}, function(error, urlInfo) {
            expect(error).to.equal(null);
            expect(urlInfo).to.be.instanceOf(Dropbox.File.ShareUrl);
            expect(urlInfo.isDirect).to.equal(false);
            expect(urlInfo.url).to.contain('//db.tt/');
            return done();
          });
        });
      });
      describe('for a Web URL created with long: true', function() {
        return it('returns an URL to a preview page', function(done) {
          return this.client.makeUrl(this.textFile, {
            long: true
          }, (function(_this) {
            return function(error, urlInfo) {
              var xhr;
              expect(error).to.equal(null);
              expect(urlInfo).to.be.instanceOf(Dropbox.File.ShareUrl);
              expect(urlInfo.isDirect).to.equal(false);
              expect(urlInfo.url).not.to.contain('//db.tt/');
              if (!_this.node_js) {
                return done();
              }
              xhr = new Dropbox.Util.Xhr('GET', urlInfo.url);
              return xhr.prepare().send(function(error, data) {
                expect(error).to.equal(null);
                expect(data).to.contain('<!DOCTYPE html>');
                return done();
              });
            };
          })(this));
        });
      });
      describe('for a Web URL created with longUrl: true', function() {
        return it('returns an URL to a preview page', function(done) {
          return this.client.makeUrl(this.textFile, {
            longUrl: true
          }, (function(_this) {
            return function(error, urlInfo) {
              expect(error).to.equal(null);
              expect(urlInfo).to.be.instanceOf(Dropbox.File.ShareUrl);
              expect(urlInfo.isDirect).to.equal(false);
              expect(urlInfo.url).not.to.contain('//db.tt/');
              return done();
            };
          })(this));
        });
      });
      describe('for a direct download URL', function() {
        return it('gets a direct download URL', function(done) {
          return this.client.makeUrl(this.textFile, {
            download: true
          }, (function(_this) {
            return function(error, urlInfo) {
              var xhr;
              expect(error).to.equal(null);
              expect(urlInfo).to.be.instanceOf(Dropbox.File.ShareUrl);
              expect(urlInfo.isDirect).to.equal(true);
              expect(urlInfo.url).not.to.contain('//db.tt/');
              xhr = new Dropbox.Util.Xhr('GET', urlInfo.url);
              return xhr.prepare().send(function(error, data) {
                expect(error).to.equal(null);
                expect(data).to.equal(_this.textFileData);
                return done();
              });
            };
          })(this));
        });
      });
      return describe('for a direct download URL created with downloadHack: true', function() {
        return it('gets a direct long-lived download URL', function(done) {
          return this.client.makeUrl(this.textFile, {
            downloadHack: true
          }, (function(_this) {
            return function(error, urlInfo) {
              var xhr;
              expect(error).to.equal(null);
              expect(urlInfo).to.be.instanceOf(Dropbox.File.ShareUrl);
              expect(urlInfo.isDirect).to.equal(true);
              expect(urlInfo.url).not.to.contain('//db.tt/');
              expect(urlInfo.expiresAt - Date.now()).to.be.above(86400000);
              xhr = new Dropbox.Util.Xhr('GET', urlInfo.url);
              return xhr.prepare().send(function(error, data) {
                expect(error).to.equal(null);
                expect(data).to.equal(_this.textFileData);
                return done();
              });
            };
          })(this));
        });
      });
    });
    describe('#thumbnailUrl', function() {
      it('produces an URL that contains the file name', function() {
        var url;
        url = this.client.thumbnailUrl(this.imageFile, {
          png: true,
          size: 'medium'
        });
        expect(url).to.contain('tests');
        expect(url).to.contain('png');
        return expect(url).to.contain('medium');
      });
      return it('produces an URL that can be used to read the image', function(done) {
        var url, xhr;
        if (typeof ArrayBuffer === "undefined" || ArrayBuffer === null) {
          return done();
        }
        url = this.client.thumbnailUrl(this.imageFile, {
          png: true,
          size: 'medium'
        });
        xhr = new Dropbox.Util.Xhr('GET', url);
        return xhr.setResponseType('arraybuffer').prepare().send((function(_this) {
          return function(error, buffer) {
            var bytes, i, length, view;
            expect(error).to.equal(null);
            expect(buffer).to.be.instanceOf(ArrayBuffer);
            view = new Uint8Array(buffer);
            length = buffer.byteLength;
            bytes = ((function() {
              var j, ref, results;
              results = [];
              for (i = j = 0, ref = length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                results.push(String.fromCharCode(view[i]));
              }
              return results;
            })()).join('');
            expect(bytes).to.contain('PNG');
            return done();
          };
        })(this));
      });
    });
    describe('#readThumbnail', function() {
      it('reads the image into a string', function(done) {
        return this.client.readThumbnail(this.imageFile, {
          png: true
        }, (function(_this) {
          return function(error, data, stat) {
            expect(error).to.equal(null);
            expect(data).to.be.a('string');
            expect(data).to.contain('PNG');
            if (!Dropbox.Util.Xhr.ieXdr) {
              expect(stat).to.be.instanceOf(Dropbox.File.Stat);
              expect(stat.path).to.equal(_this.imageFile);
            }
            return done();
          };
        })(this));
      });
      it('reads the image into a Blob', function(done) {
        var options;
        if (typeof Blob === "undefined" || Blob === null) {
          return done();
        }
        options = {
          png: true,
          blob: true
        };
        return this.client.readThumbnail(this.imageFile, options, (function(_this) {
          return function(error, blob, stat) {
            var buffer, onBufferAvailable, reader;
            expect(error).to.equal(null);
            expect(blob).to.be.instanceOf(Blob);
            if (!Dropbox.Util.Xhr.ieXdr) {
              expect(stat).to.be.instanceOf(Dropbox.File.Stat);
              expect(stat.path).to.equal(_this.imageFile);
              expect(stat.isFile).to.equal(true);
            }
            onBufferAvailable = function(buffer) {
              var bytes, i, length, view;
              view = new Uint8Array(buffer);
              length = buffer.byteLength;
              bytes = ((function() {
                var j, ref, results;
                results = [];
                for (i = j = 0, ref = length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                  results.push(String.fromCharCode(view[i]));
                }
                return results;
              })()).join('');
              expect(bytes).to.contain('PNG');
              return done();
            };
            if (typeof FileReaderSync !== 'undefined') {
              reader = new FileReaderSync;
              buffer = reader.readAsArrayBuffer(blob);
              return onBufferAvailable(buffer);
            } else {
              reader = new FileReader;
              reader.onloadend = function() {
                if (reader.readyState !== FileReader.DONE) {
                  return;
                }
                return onBufferAvailable(reader.result);
              };
              return reader.readAsArrayBuffer(blob);
            }
          };
        })(this));
      });
      it('reads the image into an ArrayBuffer', function(done) {
        var options;
        if (typeof ArrayBuffer === "undefined" || ArrayBuffer === null) {
          return done();
        }
        options = {
          png: true,
          arrayBuffer: true
        };
        return this.client.readThumbnail(this.imageFile, options, (function(_this) {
          return function(error, buffer, stat) {
            var bytes, i, length, view;
            expect(error).to.equal(null);
            expect(buffer).to.be.instanceOf(ArrayBuffer);
            if (!Dropbox.Util.Xhr.ieXdr) {
              expect(stat).to.be.instanceOf(Dropbox.File.Stat);
              expect(stat.path).to.equal(_this.imageFile);
              expect(stat.isFile).to.equal(true);
            }
            view = new Uint8Array(buffer);
            length = buffer.byteLength;
            bytes = ((function() {
              var j, ref, results;
              results = [];
              for (i = j = 0, ref = length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                results.push(String.fromCharCode(view[i]));
              }
              return results;
            })()).join('');
            expect(bytes).to.contain('PNG');
            return done();
          };
        })(this));
      });
      return it('reads the image into a node.js Buffer', function(done) {
        var options;
        if (typeof Buffer === "undefined" || Buffer === null) {
          return done();
        }
        options = {
          png: true,
          buffer: true
        };
        return this.client.readThumbnail(this.imageFile, options, (function(_this) {
          return function(error, buffer, stat) {
            var bytes, i, length;
            expect(error).to.equal(null);
            expect(buffer).to.be.instanceOf(Buffer);
            if (!Dropbox.Util.Xhr.ieXdr) {
              expect(stat).to.be.instanceOf(Dropbox.File.Stat);
              expect(stat.path).to.equal(_this.imageFile);
              expect(stat.isFile).to.equal(true);
            }
            length = buffer.length;
            bytes = ((function() {
              var j, ref, results;
              results = [];
              for (i = j = 0, ref = length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                results.push(String.fromCharCode(buffer.readUInt8(i)));
              }
              return results;
            })()).join('');
            expect(bytes).to.contain('PNG');
            return done();
          };
        })(this));
      });
    });
    describe('#pullChanges', function() {
      describe('with valid args', function() {
        beforeEach(function() {
          this.timeoutValue = 60 * 1000;
          return this.timeout(this.timeoutValue);
        });
        afterEach(function(done) {
          this.timeoutValue += 10 * 1000;
          this.timeout(this.timeoutValue);
          if (!this.newFile) {
            return done();
          }
          return this.client.remove(this.newFile, function(error, stat) {
            return done();
          });
        });
        return it('gets a cursor, then it gets relevant changes', function(done) {
          this.timeout(this.timeoutValue);
          return this.client.pullChanges((function(_this) {
            return function(error, changes) {
              var drainEntries;
              expect(error).to.equal(null);
              expect(changes).to.be.instanceOf(Dropbox.Http.PulledChanges);
              expect(changes.blankSlate).to.equal(true);
              drainEntries = function(client, callback) {
                if (!changes.shouldPullAgain) {
                  return callback();
                }
                _this.timeoutValue += 10 * 1000;
                _this.timeout(_this.timeoutValue);
                return client.pullChanges(changes, function(error, _changes) {
                  expect(error).to.equal(null);
                  changes = _changes;
                  return drainEntries(client, callback);
                });
              };
              return drainEntries(_this.client, function() {
                var newFileData;
                _this.newFile = _this.testFolder + "/delta-test.txt";
                newFileData = "This file is used to test pullChanges.\n";
                return _this.client.writeFile(_this.newFile, newFileData, function(error, stat) {
                  expect(error).to.equal(null);
                  expect(stat).to.have.property('path');
                  expect(stat.path).to.equal(_this.newFile);
                  return _this.client.pullChanges(changes, function(error, changes) {
                    var change;
                    expect(error).to.equal(null);
                    expect(changes).to.be.instanceOf(Dropbox.Http.PulledChanges);
                    expect(changes.blankSlate).to.equal(false);
                    expect(changes.changes).to.have.length.greaterThan(0);
                    change = changes.changes[changes.changes.length - 1];
                    expect(change).to.be.instanceOf(Dropbox.Http.PulledChange);
                    expect(change.path).to.equal(_this.newFile);
                    expect(change.wasRemoved).to.equal(false);
                    expect(change.stat.path).to.equal(_this.newFile);
                    return done();
                  });
                });
              });
            };
          })(this));
        });
      });
      return describe('with a bad cursor', function() {
        return it('returns an error', function(done) {
          return this.client.pullChanges('[troll-cursor]', function(error, changes) {
            expect(changes).not.to.be.ok;
            expect(error).to.be.instanceOf(Dropbox.ApiError);
            if (!Dropbox.Util.Xhr.ieXdr) {
              expect(error).to.have.property('status');
              expect(error.status).to.equal(Dropbox.ApiError.INVALID_PARAM);
              return done();
            }
          });
        });
      });
    });
    describe('#pollForChanges', function() {
      describe('with a valid cursor', function() {
        beforeEach(function(done) {
          this.timeoutValue = 60 * 1000;
          this.timeout(this.timeoutValue);
          return this.client.pullChanges((function(_this) {
            return function(error, changes) {
              var delayedDrainEntries, drainEntries;
              expect(error).to.equal(null);
              expect(changes).to.be.instanceOf(Dropbox.Http.PulledChanges);
              drainEntries = function(client, callback) {
                if (!changes.shouldPullAgain) {
                  return callback();
                }
                _this.timeoutValue += 10 * 1000;
                _this.timeout(_this.timeoutValue);
                return client.pullChanges(changes, function(error, _changes) {
                  expect(error).to.equal(null);
                  changes = _changes;
                  return drainEntries(client, callback);
                });
              };
              delayedDrainEntries = function() {
                return drainEntries(_this.client, function() {
                  _this.changes = changes;
                  return done();
                });
              };
              return setTimeout(delayedDrainEntries, 3000);
            };
          })(this));
        });
        afterEach(function(done) {
          this.timeoutValue += 10 * 1000;
          this.timeout(this.timeoutValue);
          if (!this.newFile) {
            return done();
          }
          return this.client.remove(this.newFile, function(error, stat) {
            return done();
          });
        });
        return it('gets notified when changes happen', function(done) {
          var fileWritten, newFileData, writeFile;
          if (!this.node_js) {
            return done();
          }
          this.timeout(this.timeoutValue);
          this.newFile = this.testFolder + "/longpoll-delta-test.txt";
          newFileData = "This file is used to test pollForChanges.\n";
          fileWritten = false;
          this.client.pollForChanges(this.changes, {
            timeout: 30
          }, (function(_this) {
            return function(error, result) {
              expect(error).to.equal(null);
              expect(result).to.be.instanceOf(Dropbox.Http.PollResult);
              expect(['hasChanges', result.hasChanges]).to.deep.equal(['hasChanges', true]);
              expect(['fileWritten', fileWritten]).to.deep.equal(['fileWritten', true]);
              return _this.client.pullChanges(_this.changes, function(error, changes) {
                var change;
                expect(error).to.equal(null);
                expect(changes).to.be.instanceOf(Dropbox.Http.PulledChanges);
                expect(changes.blankSlate).to.equal(false);
                expect(changes.changes).to.have.length.greaterThan(0);
                change = changes.changes[changes.changes.length - 1];
                expect(change).to.be.instanceOf(Dropbox.Http.PulledChange);
                expect(change.path).to.equal(_this.newFile);
                expect(change.wasRemoved).to.equal(false);
                expect(change.stat.path).to.equal(_this.newFile);
                return done();
              });
            };
          })(this));
          writeFile = (function(_this) {
            return function() {
              fileWritten = true;
              return _this.client.writeFile(_this.newFile, newFileData, function(error, stat) {
                expect(error).to.equal(null);
                expect(stat).to.have.property('path');
                return expect(stat.path).to.equal(_this.newFile);
              });
            };
          })(this);
          return setTimeout(writeFile, 3000);
        });
      });
      return describe('with an invalid cursor', function() {
        return it('returns an error', function(done) {
          if (!this.node_js) {
            return done();
          }
          return this.client.pollForChanges('[troll-cursor]', function(error, changes) {
            expect(changes).not.to.be.ok;
            expect(error).to.be.instanceOf(Dropbox.ApiError);
            if (!Dropbox.Util.Xhr.ieXdr) {
              expect(error).to.have.property('status');
              expect(error.status).to.equal(Dropbox.ApiError.INVALID_PARAM);
              return done();
            }
          });
        });
      });
    });
    describe('#appInfo', function() {
      it('returns an error for non-existing app keys', function(done) {
        return this.client.appInfo('no0such0key', function(error, appInfo) {
          expect(appInfo).not.to.be.ok;
          expect(error).to.be.instanceOf(Dropbox.ApiError);
          if (!Dropbox.Util.Xhr.ieXdr) {
            expect(error.status).to.equal(Dropbox.ApiError.INVALID_PARAM);
          }
          return done();
        });
      });
      it('uses the client key if no key is given', function(done) {
        return this.client.appInfo(function(error, appInfo) {
          expect(error).to.equal(null);
          expect(appInfo).to.be.instanceOf(Dropbox.Http.AppInfo);
          expect(appInfo.name).to.match(/Automated Testing Keys/i);
          expect(appInfo.key).to.equal(clientKeys.key);
          expect(appInfo.canUseDatastores).to.equal(true);
          expect(appInfo.canUseFiles).to.equal(true);
          if (clientKeys.key === testFullDropboxKeys.key) {
            expect(appInfo.canUseFullDropbox).to.equal(true);
          } else {
            expect(appInfo.canUseFullDropbox).to.equal(false);
          }
          expect(appInfo.icon(Dropbox.Http.AppInfo.ICON_SMALL)).to.be.a('string');
          expect(appInfo.icon(Dropbox.Http.AppInfo.ICON_LARGE)).to.be.a('string');
          return done();
        });
      });
      it('uses a key if given', function(done) {
        var expectFullDropbox, otherKey;
        if (clientKeys.key === testFullDropboxKeys.key) {
          otherKey = testKeys.key;
          expectFullDropbox = false;
        } else {
          otherKey = testFullDropboxKeys.key;
          expectFullDropbox = true;
        }
        return this.client.appInfo(otherKey, function(error, appInfo) {
          expect(error).to.equal(null);
          expect(appInfo).to.be.instanceOf(Dropbox.Http.AppInfo);
          expect(appInfo.name).to.match(/Automated Testing Keys/i);
          expect(appInfo.key).to.equal(otherKey);
          expect(appInfo.canUseFullDropbox).to.equal(expectFullDropbox);
          return done();
        });
      });
      return it('returns valid PNG icons', function(done) {
        return this.client.appInfo(function(error, appInfo) {
          var largeUrl, smallUrl, smallXhr;
          expect(error).to.equal(null);
          expect(appInfo).to.be.instanceOf(Dropbox.Http.AppInfo);
          smallUrl = appInfo.icon(Dropbox.Http.AppInfo.ICON_SMALL);
          largeUrl = appInfo.icon(Dropbox.Http.AppInfo.ICON_LARGE);
          expect(smallUrl).to.be.a('string');
          expect(largeUrl).to.be.a('string');
          expect(smallUrl).not.to.equal(largeUrl);
          smallXhr = new Dropbox.Util.Xhr('GET', smallUrl);
          return smallXhr.prepare().send((function(_this) {
            return function(error, data) {
              var largeXhr;
              expect(error).to.equal(null);
              expect(data).to.contain('PNG');
              largeXhr = new Dropbox.Util.Xhr('GET', largeUrl);
              return largeXhr.prepare().send(function(error, data) {
                expect(error).to.equal(null);
                expect(data).to.contain('PNG');
                return done();
              });
            };
          })(this));
        });
      });
    });
    describe('#isAppDeveloper', function() {
      it('returns an error for non-existing app keys', function(done) {
        return this.client.isAppDeveloper(1, 'no0such0key', function(error, isAppDeveloper) {
          expect(isAppDeveloper).to.equal(void 0);
          expect(error).to.be.instanceOf(Dropbox.ApiError);
          if (!Dropbox.Util.Xhr.ieXdr) {
            expect(error.status).to.equal(Dropbox.ApiError.INVALID_PARAM);
          }
          return done();
        });
      });
      it('uses the client key if no key is given', function(done) {
        return this.client.isAppDeveloper(1, function(error, isDeveloper) {
          expect(error).to.equal(null);
          expect(isDeveloper).to.equal(false);
          return done();
        });
      });
      return it('works with AppInfo instances', function(done) {
        return this.client.appInfo((function(_this) {
          return function(error, appInfo) {
            var client, credentials;
            expect(error).to.equal(null);
            credentials = _this.client.credentials();
            delete credentials['key'];
            client = new Dropbox.Client(credentials);
            return client.isAppDeveloper(1, appInfo, function(error, isDeveloper) {
              expect(error).to.equal(null);
              expect(isDeveloper).to.equal(false);
              return done();
            });
          };
        })(this));
      });
    });
    describe('#hasOauthRedirectUri', function() {
      beforeEach(function() {
        this.yesUri = 'https://www.dropbox.com/1/oauth2/redirect_receiver';
        return this.noUri = 'https://www.dropbox.com/not/really/registered';
      });
      it('returns an error for non-existing app keys', function(done) {
        return this.client.hasOauthRedirectUri(this.yesUri, 'no0such0key', function(error, hasUri) {
          expect(hasUri).to.equal(void 0);
          expect(error).to.be.instanceOf(Dropbox.ApiError);
          if (!Dropbox.Util.Xhr.ieXdr) {
            expect(error.status).to.equal(Dropbox.ApiError.INVALID_PARAM);
          }
          return done();
        });
      });
      it('uses the client key if no key is given', function(done) {
        return this.client.hasOauthRedirectUri(this.yesUri, function(error, hasUri) {
          expect(error).to.equal(null);
          expect(hasUri).to.equal(true);
          return done();
        });
      });
      it('reports missing URIs correctly', function(done) {
        return this.client.hasOauthRedirectUri(this.noUri, function(error, hasUri) {
          expect(error).to.equal(null);
          expect(hasUri).to.equal(false);
          return done();
        });
      });
      return it('works with AppInfo instances', function(done) {
        return this.client.appInfo((function(_this) {
          return function(error, appInfo) {
            var client, credentials;
            expect(error).to.equal(null);
            credentials = _this.client.credentials();
            delete credentials['key'];
            client = new Dropbox.Client(credentials);
            return client.hasOauthRedirectUri(_this.noUri, appInfo, function(error, hasUri) {
              expect(error).to.equal(null);
              expect(hasUri).to.equal(false);
              return done();
            });
          };
        })(this));
      });
    });
    describe('#appHash', function() {
      it('is consistent', function() {
        var client;
        client = new Dropbox.Client(clientKeys);
        return expect(client.appHash()).to.equal(this.client.appHash());
      });
      return it('is a non-trivial string', function() {
        expect(this.client.appHash()).to.be.a('string');
        return expect(this.client.appHash().length).to.be.greaterThan(4);
      });
    });
    describe('#isAuthenticated', function() {
      it('is true for a client with full tokens', function() {
        return expect(this.client.isAuthenticated()).to.equal(true);
      });
      return it('is false for a freshly reset client', function() {
        this.client.reset();
        return expect(this.client.isAuthenticated()).to.equal(false);
      });
    });
    return describe('#authenticate', function() {
      return describe('with interactive: false', function() {
        beforeEach(function() {
          this.driver = {
            doAuthorize: function() {
              return assert(false, 'The OAuth driver should not be invoked');
            },
            url: function() {
              return 'https://localhost:8912/oauth_redirect';
            }
          };
          return this.client.authDriver(this.driver);
        });
        return it('proceeds from AUTHORIZED with interactive: false', function(done) {
          var credentials;
          this.client.reset();
          credentials = this.client.credentials();
          if ('__secret' in clientKeys) {
            credentials.secret = clientKeys.__secret;
          }
          credentials.oauthCode = 'invalid_authorization_code';
          this.client.setCredentials(credentials);
          expect(this.client.authStep).to.equal(Dropbox.Client.AUTHORIZED);
          return this.client.authenticate({
            interactive: false
          }, function(error, client) {
            expect(error).to.be.ok;
            if (!Dropbox.Util.Xhr.ieXdr) {
              expect(error).to.be.instanceOf(Dropbox.AuthError);
              expect(error).to.have.property('code');
              expect(error.code).to.equal(Dropbox.AuthError.INVALID_GRANT);
              expect(error).to.have.property('description');
              expect(error.description).to.match(/code.*exist.*expired/i);
            }
            return done();
          });
        });
      });
    });
  };

  describe('Dropbox.Client', function() {
    if (!((typeof self !== 'undefined') && (typeof window === 'undefined'))) {
      describe('with full Dropbox access', function() {
        return buildClientTests(testFullDropboxKeys);
      });
    }
    return describe('with Folder access', function() {
      buildClientTests(testKeys);
      describe('#authenticate + #signOut', function() {
        return it('completes the authenticate flow', function(done) {
          var authStepChanges;
          if ((typeof self !== 'undefined') && (typeof window === 'undefined')) {
            return done();
          }
          this.timeout(45 * 1000);
          this.client.reset();
          this.client.authDriver(authDriver);
          authStepChanges = ['authorize'];
          this.client.onAuthStepChange.addListener(function(client) {
            return authStepChanges.push(client.authStep);
          });
          return this.client.authenticate((function(_this) {
            return function(error, client) {
              expect(error).to.equal(null);
              expect(client).to.equal(_this.client);
              expect(client.authStep).to.equal(Dropbox.Client.DONE);
              expect(client.isAuthenticated()).to.equal(true);
              if (testKeys.secret) {
                expect(authStepChanges).to.deep.equal(['authorize', Dropbox.Client.PARAM_SET, Dropbox.Client.AUTHORIZED, Dropbox.Client.DONE]);
              } else {
                expect(authStepChanges).to.deep.equal(['authorize', Dropbox.Client.PARAM_SET, Dropbox.Client.DONE]);
              }
              return client.getAccountInfo(function(error, accountInfo) {
                var invalidCredentials;
                expect(error).to.equal(null);
                expect(accountInfo).to.be.instanceOf(Dropbox.AccountInfo);
                invalidCredentials = client.credentials();
                authStepChanges = ['signOut'];
                return client.signOut(function(error) {
                  var invalidClient;
                  expect(error).to.equal(null);
                  expect(client.authStep).to.equal(Dropbox.Client.SIGNED_OUT);
                  expect(client.isAuthenticated()).to.equal(false);
                  expect(authStepChanges).to.deep.equal(['signOut', Dropbox.Client.SIGNED_OUT]);
                  invalidClient = new Dropbox.Client(invalidCredentials);
                  invalidClient.onAuthStepChange.addListener(function(client) {
                    return authStepChanges.push(client.authStep);
                  });
                  authStepChanges = ['invalidClient'];
                  invalidClient.authDriver({
                    onAuthStepChange: function(client, callback) {
                      expect(authStepChanges).to.deep.equal(['invalidClient', Dropbox.Client.ERROR]);
                      authStepChanges.push('driver-' + client.authStep);
                      return callback();
                    }
                  });
                  invalidClient.onError.addListener(function(client) {
                    expect(authStepChanges).to.deep.equal(['invalidClient', Dropbox.Client.ERROR, 'driver-' + Dropbox.Client.ERROR]);
                    return authStepChanges.push('onError');
                  });
                  return invalidClient.getAccountInfo(function(error, accountInfo) {
                    expect(error).to.be.ok;
                    if (!Dropbox.Util.Xhr.ieXdr) {
                      expect(error.status).to.equal(Dropbox.ApiError.INVALID_TOKEN);
                      expect(invalidClient.authError).to.equal(error);
                      expect(invalidClient.isAuthenticated()).to.equal(false);
                      expect(authStepChanges).to.deep.equal(['invalidClient', Dropbox.Client.ERROR, 'driver-' + Dropbox.Client.ERROR, 'onError']);
                    }
                    authStepChanges = ['authorize2'];
                    return client.authenticate(function(error, client) {
                      expect(error).to.equal(null);
                      expect(client.authStep).to.equal(Dropbox.Client.DONE);
                      expect(client.isAuthenticated()).to.equal(true);
                      if (testKeys.secret) {
                        expect(authStepChanges).to.deep.equal(['authorize2', Dropbox.Client.PARAM_SET, Dropbox.Client.AUTHORIZED, Dropbox.Client.DONE]);
                      } else {
                        expect(authStepChanges).to.deep.equal(['authorize2', Dropbox.Client.PARAM_SET, Dropbox.Client.DONE]);
                      }
                      return client.getAccountInfo(function(error, accountInfo) {
                        expect(error).to.equal(null);
                        expect(accountInfo).to.be.instanceOf(Dropbox.AccountInfo);
                        return done();
                      });
                    });
                  });
                });
              });
            };
          })(this));
        });
      });
      return describe('#appHash', function() {
        return it('depends on the app key', function() {
          var client;
          client = new Dropbox.Client(testFullDropboxKeys);
          return expect(client.appHash()).not.to.equal(this.client.appHash());
        });
      });
    });
  });

}).call(this);
